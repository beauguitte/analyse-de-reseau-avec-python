[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse de réseau avec Python et NetworkX",
    "section": "",
    "text": "Je n’utilise pas l’écriture épicène, j’écris le plus souvent au féminin et utilise l’accord de proximité.↩︎"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "See Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, D. E. (1984). Literate programming. Comput. J., 27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Beauguitte, L. (2023). L’analyse de réseau en sciences\nsociales. Petit guide pratique. Groupe fmr. https://hal.science/hal-04052709"
  },
  {
    "objectID": "C4_partitions.html#blockmodel",
    "href": "C4_partitions.html#blockmodel",
    "title": "4  Partitions",
    "section": "4.2 Blockmodel",
    "text": "4.2 Blockmodel"
  },
  {
    "objectID": "C4_partitions.html#détection-de-communautés",
    "href": "C4_partitions.html#détection-de-communautés",
    "title": "4  Partitions",
    "section": "4.3 Détection de communautés",
    "text": "4.3 Détection de communautés"
  },
  {
    "objectID": "C3_mesurer.html#mesures-locales",
    "href": "C3_mesurer.html#mesures-locales",
    "title": "3  Mesures",
    "section": "3.2 Mesures locales",
    "text": "3.2 Mesures locales"
  },
  {
    "objectID": "conclusion.html#avec-python",
    "href": "conclusion.html#avec-python",
    "title": "7  Pour aller plus loin",
    "section": "7.2 Avec Python",
    "text": "7.2 Avec Python"
  },
  {
    "objectID": "C1_importer.html",
    "href": "C1_importer.html",
    "title": "1  Importer ses données",
    "section": "",
    "text": "La table som_d13.csv contient les attributs suivants :\n\nCODGEO : code INSEE de la commune ;\nP19_POP : population résidente en 2019 (entiers) ;\nSUPERF : superficie (flottants) ;\nSUP_QUALI : superficie inférieure ou supérieure à la moyenne départementale (chaîne de caractères). Des données ont été volontairement supprimés pour voir comment gérer les données manquantes ;\nNOM : nom de la commune ;\nMARS : variable booléenne permettant de savoir si la commune est un arrondissement de Marseille (1) ou non (0).\n\nLa table liens_d13.csv contient les attributs suivants :\n\nOrigine : code INSEE de la commune de départ ;\nArrivee : code INSEE de la commune d’arrivée ;\nweight : flux d’élèves entre communes (flux > 100).\n\nCes deux fichiers encodés en utf-8 permettent de créer un réseau simple, orienté et valué. Les réseaux autres (bimodaux, multiplexes, avec boucles) ne sont pas évoqués dans ce document.\nPour l’importation et la manipulation des données, soit vous savez utiliser Python et vous n’avez pas besoin de lire les paragraphes qui suivent, soit vous débutez en Python et utiliser le module pandas est recommmandé.\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\n\nAvant de transformer ces tables en un réseau, il est prudent de contrôler le typage par défaut qu’a choisi pandas lors de l’importation avec la fonction dtypes. Il faut en effet que les codes INSEE soient considérés comme des chaînes de caractères (str) et non comme des entiers (int64), et que la variable MARS soit considérée comme une variable booléenne (bool).\n\nprint(sommets.dtypes)\nprint(liens.dtypes)\n\nCODGEO         int64\nP19_POP        int64\nSUPERF       float64\nSUP_QUALI     object\nNOM           object\nMARS           int64\ndtype: object\nOrigine    int64\nArrivee    int64\nweight     int64\ndtype: object\n\n\nLes lignes ci-dessous permettent de typer correctement les données.\n\n# typage des variables\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\n\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\n\nLa syntaxe pour créer un réseau orienté à partir d’une liste de liens est relativement simple. On précise quelle est la colonne des origines, celle des destinations, s’il existe une valuation des liens et si le graphe est orienté. Pour que le réseau soit considéré comme valué, la colonne des intensités doit s’appeler weight ; il n’y a pas de contrainte particulière concernant les noms de colonnes correspondant aux sommets. Si le réseau est non orienté, on utilise la fonction Graph().\n\nG = nx.from_pandas_edgelist(liens,                     # data.frame des liens\n                            source = \"Origine\",        # nom de la colonne origine\n                            target = \"Arrivee\",        # nom de la colonne destination\n                            edge_attr=\"weight\",        # attribut poids pour un réseau valué\n                            create_using=nx.DiGraph()) # création d'un réseau orienté\n\nLa gestion des attributs des sommets est un tout petit peu plus complexe et la documentation du module n’aide pas vraiment. La solution la plus simple, trouvée en ligne à cette adresse, est d’utiliser la fonction set_index du module pandas. On crée un objet correspondant aux attributs des sommets, on indique quel est l’identifiant (ici CODGEO) et on lui demande de transformer le tableau de données en dictionnaire.\n\nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n\n#contrôle\nG.nodes(\"MARS\")\n\nNodeDataView({'13001': False, '13041': False, '13201': True, '13205': True, '13208': True, '13209': True, '13213': True, '13002': False, '13206': True, '13211': True, '13212': True, '13003': False, '13053': False, '13103': False, '13004': False, '13078': False, '13097': False, '13005': False, '13028': False, '13042': False, '13119': False, '13210': True, '13007': False, '13014': False, '13117': False, '13015': False, '13016': False, '13086': False, '13018': False, '13089': False, '13019': False, '13020': False, '13046': False, '13022': False, '13023': False, '13024': False, '13050': False, '13025': False, '13026': False, '13043': False, '13054': False, '13056': False, '13030': False, '13031': False, '13032': False, '13033': False, '13035': False, '13036': False, '13100': False, '13037': False, '13038': False, '13039': False, '13047': False, '13077': False, '13040': False, '13044': False, '13045': False, '13083': False, '13108': False, '13063': False, '13048': False, '13074': False, '13049': False, '13051': False, '13052': False, '13102': False, '13104': False, '13059': False, '13060': False, '13062': False, '13064': False, '13065': False, '13066': False, '13027': False, '13068': False, '13069': False, '13070': False, '13071': False, '13072': False, '13087': False, '13073': False, '13075': False, '13076': False, '13067': False, '13079': False, '13080': False, '13081': False, '13082': False, '13084': False, '13085': False, '13088': False, '13091': False, '13092': False, '13094': False, '13095': False, '13098': False, '13101': False, '13105': False, '13106': False, '13107': False, '13109': False, '13110': False, '13111': False, '13112': False, '13113': False, '13114': False, '13118': False, '13202': True, '13203': True, '13204': True, '13214': True, '13215': True, '13207': True, '13216': True}, data='MARS')\n\n\nPlusieurs moyens permettent de contrôler que l’importation s’est bien déroulée :\n\nafficher l’ordre (nombre de sommets) ;\nafficher la taille (nombre de liens) ;\ncontrôler les caractéristiques du réseau ;\nvisualiser le réseau obtenu.\n\n\nprint(\"Ordre\", nx.number_of_nodes(G), \" sommets\")\nprint(\"Taille\", nx.number_of_edges(G), \" liens\")\nprint(\"Réseau orienté ?\", nx.is_directed(G))\n\n# attribut des liens\nprint(\"attribut des liens : \", list(list(G.edges(data=True))[0][-1].keys()))\n\n# attributs des sommets\nprint(\"attribut des sommets : \", list(list(G.nodes(data=True))[0][-1].keys()))\n\n# visualisation basique\nnx.draw(G, with_labels=False)\n\nOrdre 114  sommets\nTaille 317  liens\nRéseau orienté ? True\nattribut des liens :  ['weight']\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS']\n\n\n\n\n\nJe ne suis pas capable à ce stade d’expliquer la syntaxe des lignes permettant d’accéder aux attributs."
  },
  {
    "objectID": "C2_filtrer.html",
    "href": "C2_filtrer.html",
    "title": "2  Filtrer, sélectionner",
    "section": "",
    "text": "2.0.2 Filtrage\nLes données sont importées, la plus grande composante connexe a été extraite. On peut souhaiter faire des sélections autres, que ce soit sur les sommets ou sur les liens. Deux optiions sont possibles : supprimer liens ou sommets selon un critère donné (remove_edges_from(), remove_nodes_from) ; sélectionner liens ou sommets selon un critère donné (subgraph()).\nSi je souhaite travailler uniquement sur le cas marseillais :\n\n# filtrage des sommets (1)\n# sélection des sommets satisfaisant la condition\n#Mars = [n for n,v in G.nodes(data=True) if v['MARS'] == True]  \n\n# création d'un sous-graphe\n#Gmars = G.subgraph(Mars)\n\n# visualisation\n#nx.draw_kamada_kawai(Gmars, with_labels=True)\n\nOn obtient le même résultat avec l’opération consistant à supprimer les sommets des communes hors Marseille :\n\n# filtrage des sommets (2)\n# sélection des sommets hors Marseille\n#nonmars = [n for n,v in G.nodes(data=True) if v['MARS'] == False] \n\n# copier le réseau de départ\n#Gmars2 = G\n\n# supprimer les communes hors Marseille\n#Gmars2.remove_nodes_from(nonmars)\n\n# visualisation\n#nx.draw_kamada_kawai(Gmars2,\n#                     with_labels=True)\n\nSi je souhaite travailler uniquement sur les flux les plus importants :\n\n# filtrer les liens\n# paramètres statistiques\nliens.describe()\n\n# fixer un seuil (ici la médiane)\nseuil = 212\n\n# identifier les liens sous ce seuil, récupérer les identifiants\nlong_edges = list(filter(lambda e: e[2] < seuil, (e for e in G.edges.data('weight'))))\nle_ids = list(e[:2] for e in long_edges)\n\n# créer une copie du réseau de départ\nGsup = G\n\n# supprimer les liens identifiés\nGsup.remove_edges_from(le_ids)\n\n# ordre, taille et visualisation\nprint(\"Nb de sommets : \", nx.number_of_nodes(Gsup))\nprint(\"Nb de liens : \", nx.number_of_edges(Gsup))\n\nnx.draw_kamada_kawai(Gsup, with_labels=True)\n\nNb de sommets :  114\nNb de liens :  159\n\n\n\n\n\nLe fait de ne conserver que les liens entraîne la suppression des sommets devenant isolés. Le nombre de liens a très logiquement été divisé par deux dans la mesure où le seuil choisi ici est la médiane.\nSi dans un réseau donné, j’ai des sommets isolés que je souhaite éliminer, j’utilise la fonction remove_nodes_from.\nSoit un réseau aléatoire de 20 sommets contenant des isolés.\n\n# générer un réseau aléatoire avec 2 isolés\nrg = nx.gnp_random_graph(20, 0.05, seed = 1)\nprint(\"Nb de sommets (isolés compris) : \", nx.number_of_nodes(rg))\n\n# liste des sommets avec un degré nul\nisoles = [node for node,degree in dict(rg.degree()).items() if degree < 1]\n\n# suppression des sommets concernés\nrg.remove_nodes_from(isoles)\nprint(\"Nb de sommets  (isolés exclus) : \", nx.number_of_nodes(rg))\n\nNb de sommets (isolés compris) :  20\nNb de sommets  (isolés exclus) :  18\n\n\n\n\n2.0.3 Agrégation\nIl peut être intéressant d’agréger différents sommets. La fonction contracted_nodes prend en argument le réseau étudié et les deux sommets à fusionner, l’option self_loops permet de contrôler la création d’une boucle et l’option copy permet de créer un nouveau réseau sans écraser le premier.\nSi je veux fusionner deux arrondissements marseillais, j’utilise le script suivant. Les lignes suivantes permettent de lister les liens entrants et sortants du sommet résultat de la fusion et de vérifier la présence (ici souhaitée) de la boucle.\n\nGA = nx.contracted_nodes(G, '13215', '13216', self_loops=True, copy=True)\nGA.in_edges('13215')   # liste des liens entrants\nGA.out_edges('13215')  # liste des liens sortants\n\nOutEdgeDataView([('13215', '13001'), ('13215', '13071'), ('13215', '13213'), ('13215', '13214'), ('13215', '13215')])\n\n\nAutre fonction d’agrégation, snap_aggregation agrége l’ensemble des sommets voisins partageant un même modalité. Le script ci-dessous crée un réseau où un sommet agrégé correspond à l’un des cas de figures suivants :\n\ncommunes hors Marseille liées entre elles et non liées à un arrondissement marseillais ;\ncommunes hors Marseille liées entre elles et liées à un arrondissement marseillais ;\narrondissements marseillais liés entre eux et non liés à des communes extérieures ;\narrondissements marseillais liés entre eux et liés à des communes extérieures.\n\nDans la mesure où il ne semble pas aisément possible de savoir quels sommets agrégés forment les super sommets (en tout cas, je n’ai pas encore trouvé l’information), peut-être est-il plus prudent d’effectuer ce type de manipulations en amont, sur le tableau de données initial.\n\n# node_attributes = ('MARS',)\n# GA = nx.snap_aggregation(G, node_attributes = node_attributes)  \n# print(\"Nb de sommets : \", nx.number_of_nodes(GA))\n# print(\"Nb de liens : \", nx.number_of_edges(GA))\n# nx.draw_kamada_kawai(GA, with_labels=False)"
  }
]