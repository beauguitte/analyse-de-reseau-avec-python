[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse de réseau avec Python et NetworkX",
    "section": "",
    "text": "Je n’utilise pas l’écriture épicène, j’écris le plus souvent au féminin et utilise l’accord de proximité.↩︎"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "See Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, D. E. (1984). Literate programming. Comput. J., 27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Beauguitte, L. (2023). L’analyse de réseau en sciences\nsociales. Petit guide pratique. Groupe fmr. https://hal.science/hal-04052709"
  },
  {
    "objectID": "C4_partitions.html#blockmodel",
    "href": "C4_partitions.html#blockmodel",
    "title": "4  Partitions",
    "section": "4.2 Blockmodel",
    "text": "4.2 Blockmodel"
  },
  {
    "objectID": "C4_partitions.html#détection-de-communautés",
    "href": "C4_partitions.html#détection-de-communautés",
    "title": "4  Partitions",
    "section": "4.3 Détection de communautés",
    "text": "4.3 Détection de communautés"
  },
  {
    "objectID": "C3_mesurer.html#mesures-locales",
    "href": "C3_mesurer.html#mesures-locales",
    "title": "3  Mesures",
    "section": "3.2 Mesures locales",
    "text": "3.2 Mesures locales\nLe degré se calcule à l’aide de la fonction degree. Si le réseau étudié est orienté, on peut utiliser in_degree et out_degree. L’argument optionnel weight permet de calculer le degré pondéré par l’intensité des liens.\n\n# degré\nprint(GD.degree())\n\n#degré entrant, sortant\nprint(GD.in_degree())\nprint(GD.out_degree())\n\n# degré entrant pondéré\nprint(GD.in_degree(weight = \"weight\"))\n\n[('13001', 72), ('13041', 6), ('13201', 24), ('13205', 23), ('13208', 20), ('13209', 22), ('13213', 33), ('13002', 8), ('13206', 23), ('13211', 16), ('13212', 16), ('13003', 2), ('13053', 2), ('13103', 16), ('13004', 8), ('13078', 2), ('13097', 4), ('13005', 19), ('13028', 7), ('13042', 2), ('13119', 3), ('13210', 17), ('13007', 2), ('13014', 2), ('13117', 11), ('13015', 1), ('13016', 3), ('13086', 2), ('13019', 1), ('13020', 1), ('13046', 5), ('13022', 3), ('13023', 1), ('13024', 1), ('13050', 3), ('13025', 1), ('13026', 4), ('13043', 7), ('13054', 11), ('13056', 10), ('13030', 2), ('13031', 1), ('13032', 1), ('13033', 2), ('13035', 1), ('13037', 4), ('13038', 1), ('13039', 3), ('13047', 9), ('13077', 4), ('13040', 3), ('13044', 1), ('13045', 2), ('13083', 1), ('13108', 3), ('13063', 5), ('13048', 2), ('13074', 3), ('13049', 1), ('13051', 3), ('13102', 3), ('13104', 2), ('13059', 2), ('13060', 3), ('13062', 2), ('13065', 2), ('13068', 1), ('13069', 3), ('13070', 2), ('13071', 8), ('13072', 2), ('13087', 3), ('13073', 1), ('13075', 2), ('13076', 1), ('13067', 2), ('13079', 2), ('13080', 2), ('13081', 2), ('13082', 2), ('13084', 2), ('13085', 2), ('13088', 1), ('13091', 2), ('13092', 2), ('13094', 1), ('13095', 1), ('13098', 2), ('13101', 1), ('13105', 3), ('13106', 3), ('13107', 1), ('13109', 1), ('13110', 1), ('13111', 1), ('13112', 3), ('13113', 1), ('13114', 2), ('13118', 2), ('13202', 7), ('13203', 16), ('13204', 15), ('13214', 14), ('13215', 13), ('13207', 10), ('13216', 4)]\n[('13001', 66), ('13041', 5), ('13201', 16), ('13205', 14), ('13208', 12), ('13209', 14), ('13213', 17), ('13002', 1), ('13206', 15), ('13211', 6), ('13212', 6), ('13003', 0), ('13053', 1), ('13103', 14), ('13004', 5), ('13078', 1), ('13097', 3), ('13005', 8), ('13028', 5), ('13042', 2), ('13119', 1), ('13210', 9), ('13007', 0), ('13014', 0), ('13117', 7), ('13015', 0), ('13016', 0), ('13086', 1), ('13019', 0), ('13020', 0), ('13046', 3), ('13022', 2), ('13023', 0), ('13024', 0), ('13050', 1), ('13025', 0), ('13026', 0), ('13043', 5), ('13054', 7), ('13056', 6), ('13030', 0), ('13031', 0), ('13032', 0), ('13033', 0), ('13035', 0), ('13037', 2), ('13038', 0), ('13039', 0), ('13047', 4), ('13077', 3), ('13040', 1), ('13044', 0), ('13045', 0), ('13083', 1), ('13108', 2), ('13063', 2), ('13048', 0), ('13074', 2), ('13049', 0), ('13051', 0), ('13102', 1), ('13104', 1), ('13059', 0), ('13060', 0), ('13062', 0), ('13065', 0), ('13068', 0), ('13069', 1), ('13070', 0), ('13071', 4), ('13072', 0), ('13087', 2), ('13073', 0), ('13075', 1), ('13076', 0), ('13067', 2), ('13079', 0), ('13080', 1), ('13081', 0), ('13082', 1), ('13084', 0), ('13085', 0), ('13088', 0), ('13091', 0), ('13092', 0), ('13094', 0), ('13095', 0), ('13098', 0), ('13101', 0), ('13105', 1), ('13106', 1), ('13107', 0), ('13109', 0), ('13110', 0), ('13111', 0), ('13112', 1), ('13113', 0), ('13114', 0), ('13118', 0), ('13202', 2), ('13203', 5), ('13204', 6), ('13214', 3), ('13215', 4), ('13207', 4), ('13216', 1)]\n[('13001', 6), ('13041', 1), ('13201', 8), ('13205', 9), ('13208', 8), ('13209', 8), ('13213', 16), ('13002', 7), ('13206', 8), ('13211', 10), ('13212', 10), ('13003', 2), ('13053', 1), ('13103', 2), ('13004', 3), ('13078', 1), ('13097', 1), ('13005', 11), ('13028', 2), ('13042', 0), ('13119', 2), ('13210', 8), ('13007', 2), ('13014', 2), ('13117', 4), ('13015', 1), ('13016', 3), ('13086', 1), ('13019', 1), ('13020', 1), ('13046', 2), ('13022', 1), ('13023', 1), ('13024', 1), ('13050', 2), ('13025', 1), ('13026', 4), ('13043', 2), ('13054', 4), ('13056', 4), ('13030', 2), ('13031', 1), ('13032', 1), ('13033', 2), ('13035', 1), ('13037', 2), ('13038', 1), ('13039', 3), ('13047', 5), ('13077', 1), ('13040', 2), ('13044', 1), ('13045', 2), ('13083', 0), ('13108', 1), ('13063', 3), ('13048', 2), ('13074', 1), ('13049', 1), ('13051', 3), ('13102', 2), ('13104', 1), ('13059', 2), ('13060', 3), ('13062', 2), ('13065', 2), ('13068', 1), ('13069', 2), ('13070', 2), ('13071', 4), ('13072', 2), ('13087', 1), ('13073', 1), ('13075', 1), ('13076', 1), ('13067', 0), ('13079', 2), ('13080', 1), ('13081', 2), ('13082', 1), ('13084', 2), ('13085', 2), ('13088', 1), ('13091', 2), ('13092', 2), ('13094', 1), ('13095', 1), ('13098', 2), ('13101', 1), ('13105', 2), ('13106', 2), ('13107', 1), ('13109', 1), ('13110', 1), ('13111', 1), ('13112', 2), ('13113', 1), ('13114', 2), ('13118', 2), ('13202', 5), ('13203', 11), ('13204', 9), ('13214', 11), ('13215', 9), ('13207', 6), ('13216', 3)]\n[('13001', 21875), ('13041', 926), ('13201', 4624), ('13205', 4649), ('13208', 2668), ('13209', 3208), ('13213', 4703), ('13002', 233), ('13206', 4730), ('13211', 1247), ('13212', 1924), ('13003', 0), ('13053', 108), ('13103', 3972), ('13004', 1127), ('13078', 173), ('13097', 367), ('13005', 1646), ('13028', 983), ('13042', 346), ('13119', 115), ('13210', 1999), ('13007', 0), ('13014', 0), ('13117', 2037), ('13015', 0), ('13016', 0), ('13086', 292), ('13019', 0), ('13020', 0), ('13046', 439), ('13022', 328), ('13023', 0), ('13024', 0), ('13050', 120), ('13025', 0), ('13026', 0), ('13043', 956), ('13054', 1433), ('13056', 1665), ('13030', 0), ('13031', 0), ('13032', 0), ('13033', 0), ('13035', 0), ('13037', 275), ('13038', 0), ('13039', 0), ('13047', 1112), ('13077', 548), ('13040', 210), ('13044', 0), ('13045', 0), ('13083', 118), ('13108', 243), ('13063', 417), ('13048', 0), ('13074', 254), ('13049', 0), ('13051', 0), ('13102', 316), ('13104', 206), ('13059', 0), ('13060', 0), ('13062', 0), ('13065', 0), ('13068', 0), ('13069', 128), ('13070', 0), ('13071', 608), ('13072', 0), ('13087', 267), ('13073', 0), ('13075', 231), ('13076', 0), ('13067', 463), ('13079', 0), ('13080', 251), ('13081', 0), ('13082', 193), ('13084', 0), ('13085', 0), ('13088', 0), ('13091', 0), ('13092', 0), ('13094', 0), ('13095', 0), ('13098', 0), ('13101', 0), ('13105', 314), ('13106', 156), ('13107', 0), ('13109', 0), ('13110', 0), ('13111', 0), ('13112', 189), ('13113', 0), ('13114', 0), ('13118', 0), ('13202', 418), ('13203', 745), ('13204', 1731), ('13214', 618), ('13215', 964), ('13207', 549), ('13216', 128)]\n\n\nAjouter _centrality à la fonction utilisée permet d’obtenir les valeurs normalisées.\n\n# degré normalisé\nprint(nx.degree_centrality(GD))\n\n{'13001': 0.6857142857142857, '13041': 0.05714285714285715, '13201': 0.2285714285714286, '13205': 0.21904761904761907, '13208': 0.1904761904761905, '13209': 0.20952380952380956, '13213': 0.31428571428571433, '13002': 0.0761904761904762, '13206': 0.21904761904761907, '13211': 0.1523809523809524, '13212': 0.1523809523809524, '13003': 0.01904761904761905, '13053': 0.01904761904761905, '13103': 0.1523809523809524, '13004': 0.0761904761904762, '13078': 0.01904761904761905, '13097': 0.0380952380952381, '13005': 0.18095238095238098, '13028': 0.06666666666666668, '13042': 0.01904761904761905, '13119': 0.028571428571428574, '13210': 0.1619047619047619, '13007': 0.01904761904761905, '13014': 0.01904761904761905, '13117': 0.10476190476190478, '13015': 0.009523809523809525, '13016': 0.028571428571428574, '13086': 0.01904761904761905, '13019': 0.009523809523809525, '13020': 0.009523809523809525, '13046': 0.04761904761904762, '13022': 0.028571428571428574, '13023': 0.009523809523809525, '13024': 0.009523809523809525, '13050': 0.028571428571428574, '13025': 0.009523809523809525, '13026': 0.0380952380952381, '13043': 0.06666666666666668, '13054': 0.10476190476190478, '13056': 0.09523809523809525, '13030': 0.01904761904761905, '13031': 0.009523809523809525, '13032': 0.009523809523809525, '13033': 0.01904761904761905, '13035': 0.009523809523809525, '13037': 0.0380952380952381, '13038': 0.009523809523809525, '13039': 0.028571428571428574, '13047': 0.08571428571428572, '13077': 0.0380952380952381, '13040': 0.028571428571428574, '13044': 0.009523809523809525, '13045': 0.01904761904761905, '13083': 0.009523809523809525, '13108': 0.028571428571428574, '13063': 0.04761904761904762, '13048': 0.01904761904761905, '13074': 0.028571428571428574, '13049': 0.009523809523809525, '13051': 0.028571428571428574, '13102': 0.028571428571428574, '13104': 0.01904761904761905, '13059': 0.01904761904761905, '13060': 0.028571428571428574, '13062': 0.01904761904761905, '13065': 0.01904761904761905, '13068': 0.009523809523809525, '13069': 0.028571428571428574, '13070': 0.01904761904761905, '13071': 0.0761904761904762, '13072': 0.01904761904761905, '13087': 0.028571428571428574, '13073': 0.009523809523809525, '13075': 0.01904761904761905, '13076': 0.009523809523809525, '13067': 0.01904761904761905, '13079': 0.01904761904761905, '13080': 0.01904761904761905, '13081': 0.01904761904761905, '13082': 0.01904761904761905, '13084': 0.01904761904761905, '13085': 0.01904761904761905, '13088': 0.009523809523809525, '13091': 0.01904761904761905, '13092': 0.01904761904761905, '13094': 0.009523809523809525, '13095': 0.009523809523809525, '13098': 0.01904761904761905, '13101': 0.009523809523809525, '13105': 0.028571428571428574, '13106': 0.028571428571428574, '13107': 0.009523809523809525, '13109': 0.009523809523809525, '13110': 0.009523809523809525, '13111': 0.009523809523809525, '13112': 0.028571428571428574, '13113': 0.009523809523809525, '13114': 0.01904761904761905, '13118': 0.01904761904761905, '13202': 0.06666666666666668, '13203': 0.1523809523809524, '13204': 0.14285714285714288, '13214': 0.13333333333333336, '13215': 0.12380952380952381, '13207': 0.09523809523809525, '13216': 0.0380952380952381}\n\n\nPour transformer une mesure en attribut, on commence par créer un objet correspondondant au résultat puis on utilise la fonction set_node_attributes si la mesure porte sur les sommets et set_edge_attributes si elle porte sur les liens.\n\n# transformer une meure en attribut \ndeg = nx.degree(GU)\nnx.set_node_attributes(GU, 'degree', deg)\nprint(\"attribut des sommets : \", list(list(GU.nodes(data=True))[0][-1].keys()))\n\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS', DegreeView({'13001': 66, '13041': 5, '13201': 16, '13205': 14, '13208': 13, '13209': 14, '13213': 18, '13002': 7, '13206': 16, '13211': 12, '13212': 13, '13003': 2, '13053': 2, '13103': 15, '13004': 6, '13078': 1, '13097': 3, '13005': 17, '13028': 6, '13042': 2, '13119': 3, '13210': 11, '13007': 2, '13014': 2, '13117': 9, '13015': 1, '13016': 3, '13086': 2, '13019': 1, '13020': 1, '13046': 5, '13022': 3, '13023': 1, '13024': 1, '13050': 3, '13025': 1, '13026': 4, '13043': 6, '13054': 8, '13056': 7, '13030': 2, '13031': 1, '13032': 1, '13033': 2, '13035': 1, '13037': 4, '13038': 1, '13039': 3, '13047': 7, '13077': 3, '13040': 3, '13044': 1, '13045': 2, '13083': 1, '13108': 3, '13063': 4, '13048': 2, '13074': 3, '13049': 1, '13051': 3, '13102': 2, '13104': 1, '13059': 2, '13060': 3, '13062': 2, '13065': 2, '13068': 1, '13069': 2, '13070': 2, '13071': 7, '13072': 2, '13087': 3, '13073': 1, '13075': 1, '13076': 1, '13067': 2, '13079': 2, '13080': 2, '13081': 2, '13082': 2, '13084': 2, '13085': 2, '13088': 1, '13091': 2, '13092': 2, '13094': 1, '13095': 1, '13098': 2, '13101': 1, '13105': 3, '13106': 3, '13107': 1, '13109': 1, '13110': 1, '13111': 1, '13112': 3, '13113': 1, '13114': 2, '13118': 2, '13202': 5, '13203': 11, '13204': 10, '13214': 11, '13215': 10, '13207': 6, '13216': 3})]\n\n\nLes lignes ci-dessous proposent différentes solutions pour visualiser la distribution des degrés :\n\nhistogramme ;\nfréquence ;\nfréquence avec une échelle log-log.\n\n\n\n\n# distribution sous forme d'histogramme\ndegree_in = sorted((d for n, d in GD.in_degree()), reverse=True)\nplt.bar(*np.unique(degree_in, return_counts=True))\nplt.title(\"Degrés entrants\")\nplt.xlabel(\"Degré\")\nplt.ylabel(\"Fréquence\")\n\n# fréquence\ndegree_sequence = sorted((d for n, d in GU.degree()), reverse=True)\n\n# distribution des degrés\nplt.plot(degree_sequence, \"r-\", marker=\"o\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n\n# distribution degré - échelle log - log\nplt.loglog(degree_sequence, \"go-\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés (log - log)\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n\nText(0, 0.5, 'Fréquence')\n\n\n\n\n\nIl est possible de calculer le degré moyen des voisins à à l’aide de la fonction average_neighbor_degree (degré entrant, sortant, total, pondéré ou non).\n\n# degré moyen des sommets voisins\nnx.average_neighbor_degree(GD)\n# degré entrant moyen des voisins entrants\nnx.average_neighbor_degree(GD, source=\"in\", target=\"in\")\n# degré moyen pondéré des voisins\nnx.average_neighbor_degree(GD, weight=\"weight\")\n\n{'13001': 9.025862068965518,\n '13041': 6.0,\n '13201': 8.973326623049823,\n '13205': 8.36310223266745,\n '13208': 8.230606488011283,\n '13209': 8.473441108545035,\n '13213': 7.856919293539012,\n '13002': 11.18537859007833,\n '13206': 8.361309138042774,\n '13211': 9.179586563307494,\n '13212': 9.52385685884692,\n '13003': 1.5609756097560976,\n '13053': 2.0,\n '13103': 5.385354141656663,\n '13004': 3.0985401459854014,\n '13078': 3.0,\n '13097': 3.0,\n '13005': 6.859547606522883,\n '13028': 7.984334203655353,\n '13042': 0.0,\n '13119': 1.4437299035369775,\n '13210': 8.472777606890187,\n '13007': 9.679435483870968,\n '13014': 4.718411552346571,\n '13117': 4.865004299226139,\n '13015': 6.0,\n '13016': 4.893653516295026,\n '13086': 11.0,\n '13019': 6.0,\n '13020': 2.0,\n '13046': 2.9871794871794872,\n '13022': 2.0,\n '13023': 2.0,\n '13024': 2.0,\n '13050': 4.412811387900356,\n '13025': 6.0,\n '13026': 4.09549795361528,\n '13043': 4.446215139442231,\n '13054': 3.6324081020255066,\n '13056': 3.2449392712550607,\n '13030': 3.513888888888889,\n '13031': 11.0,\n '13032': 6.0,\n '13033': 2.756218905472637,\n '13035': 2.0,\n '13037': 3.61,\n '13038': 3.0,\n '13039': 4.014175257731959,\n '13047': 3.6373937677053823,\n '13077': 4.0,\n '13040': 4.067484662576687,\n '13044': 2.0,\n '13045': 0.5203252032520326,\n '13083': 0.0,\n '13108': 3.0,\n '13063': 4.390894819466248,\n '13048': 4.242009132420091,\n '13074': 6.0,\n '13049': 2.0,\n '13051': 2.7255813953488373,\n '13102': 4.0,\n '13104': 4.0,\n '13059': 4.759305210918114,\n '13060': 3.743732590529248,\n '13062': 2.7690058479532165,\n '13065': 1.975609756097561,\n '13068': 1.0,\n '13069': 3.135566188197767,\n '13070': 10.550387596899224,\n '13071': 4.359848484848484,\n '13072': 3.074074074074074,\n '13087': 6.0,\n '13073': 2.0,\n '13075': 16.0,\n '13076': 0.0,\n '13067': 0.0,\n '13079': 3.6096491228070176,\n '13080': 6.0,\n '13081': 4.79672131147541,\n '13082': 6.0,\n '13084': 3.5,\n '13085': 1.4150943396226414,\n '13088': 4.0,\n '13091': 4.378151260504202,\n '13092': 2.556497175141243,\n '13094': 1.0,\n '13095': 6.0,\n '13098': 4.760956175298805,\n '13101': 2.0,\n '13105': 0.8786324786324786,\n '13106': 5.336609336609337,\n '13107': 6.0,\n '13109': 6.0,\n '13110': 6.0,\n '13111': 6.0,\n '13112': 5.326530612244898,\n '13113': 6.0,\n '13114': 4.88,\n '13118': 4.4,\n '13202': 9.09049773755656,\n '13203': 7.443720121686224,\n '13204': 9.178610010803025,\n '13214': 10.215070643642072,\n '13215': 7.080076263107721,\n '13207': 7.804682686383241,\n '13216': 7.573268921095008}\n\n\nLes mesures de centralité autres s’obtiennent avec des fonctions aux noms attendus : closeness, betweenness (edge_betweenness pour l’intermédiarité des liens), eigenvector_centrality et katz_centrality.\n\n# intermédiarité\nnx.betweenness_centrality(GD)\nL`` \n# intermédiarité des liens\nnx.edge_betweenness_centrality(GD)\n\n# proximité\nnx.closeness_centrality(GD)\n\n# centralité de vecteur propre\nnx.eigenvector_centrality(GD)\n\n# centralité de Katz\nnx.katz_centrality(GD)\n\n\nConcernant la recherche de la transitivité, on peut connaître le nom de triangles (triades fermées) contenant chaque sommet avec la fonction triangles. La transitivité locale s’obtient avec clustering, la transitivité globale avec transitivity et la transitivité moyenne avec average_clustering. Il est possible de prendre en compte l’orientation des liens et/ou leur intensité.\n\n# transitivité locale\nnx.clustering(GD)\n# prise en compte de l'intensité des liens\nnx.clustering(GD, weight=\"weight\")\n\n\n# transitivité globale et moyenne\nprint(\"Transitivité globale (orienté) : \", round(nx.transitivity(GD), 2))\nprint(\"Transitivité moyenne (orienté) : \", round(nx.average_clustering(GD), 2))\nprint(\"Transitivité globale (non orienté) : \", round(nx.transitivity(GU), 2))\nprint(\"Transitivité moyenne (non orienté) : \", round(nx.average_clustering(GU), 2))\n\nTransitivité globale (orienté) :  0.62\nTransitivité moyenne (orienté) :  0.35\nTransitivité globale (non orienté) :  0.29\nTransitivité moyenne (non orienté) :  0.54"
  },
  {
    "objectID": "conclusion.html#avec-python",
    "href": "conclusion.html#avec-python",
    "title": "7  Pour aller plus loin",
    "section": "7.2 Avec Python",
    "text": "7.2 Avec Python"
  },
  {
    "objectID": "C1_importer.html",
    "href": "C1_importer.html",
    "title": "1  Importer ses données",
    "section": "",
    "text": "La table som_d13.csv contient les attributs suivants :\n\nCODGEO : code INSEE de la commune ;\nP19_POP : population résidente en 2019 (entiers) ;\nSUPERF : superficie (flottants) ;\nSUP_QUALI : superficie inférieure ou supérieure à la moyenne départementale (chaîne de caractères). Des données ont été volontairement supprimés pour voir comment gérer les données manquantes ;\nNOM : nom de la commune ;\nMARS : variable booléenne permettant de savoir si la commune est un arrondissement de Marseille (1) ou non (0).\n\nLa table liens_d13.csv contient les attributs suivants :\n\nOrigine : code INSEE de la commune de départ ;\nArrivee : code INSEE de la commune d’arrivée ;\nweight : flux d’élèves entre communes (flux > 100).\n\nCes deux fichiers encodés en utf-8 permettent de créer un réseau simple, orienté et valué. Les réseaux autres (bimodaux, multiplexes, avec boucles) ne sont pas évoqués dans ce document.\nPour l’importation et la manipulation des données, soit vous savez utiliser Python et vous n’avez pas besoin de lire les paragraphes qui suivent, soit vous débutez en Python et utiliser le module pandas est recommmandé.\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\n\nAvant de transformer ces tables en un réseau, il est prudent de contrôler le typage par défaut qu’a choisi pandas lors de l’importation avec la fonction dtypes. Il faut en effet que les codes INSEE soient considérés comme des chaînes de caractères (str) et non comme des entiers (int64), et que la variable MARS soit considérée comme une variable booléenne (bool).\n\nprint(sommets.dtypes)\nprint(liens.dtypes)\n\nCODGEO         int64\nP19_POP        int64\nSUPERF       float64\nSUP_QUALI     object\nNOM           object\nMARS           int64\ndtype: object\nOrigine    int64\nArrivee    int64\nweight     int64\ndtype: object\n\n\nLes lignes ci-dessous permettent de typer correctement les données.\n\n# typage des variables\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\n\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\n\nLa syntaxe pour créer un réseau orienté à partir d’une liste de liens est relativement simple. On précise quelle est la colonne des origines, celle des destinations, s’il existe une valuation des liens et si le graphe est orienté.\nPour que le réseau soit considéré comme valué, la colonne des intensités doit s’appeler weight ; il n’y a pas de contrainte particulière concernant les noms de colonnes correspondant aux sommets. Si le réseau est non orienté, on utilise la fonction Graph() et non Digraph().\n\nG = nx.from_pandas_edgelist(liens,                     # data.frame des liens\n                            source = \"Origine\",        # nom de la colonne origine\n                            target = \"Arrivee\",        # nom de la colonne destination\n                            edge_attr=\"weight\",        # attribut poids pour un réseau valué\n                            create_using=nx.DiGraph()) # création d'un réseau orienté\n\nLa gestion des attributs des sommets est un tout petit peu plus complexe et la documentation du module n’aide pas vraiment. La solution la plus simple, trouvée en ligne à cette adresse, est d’utiliser la fonction set_index du module pandas. On crée un objet correspondant aux attributs des sommets, on indique quel est l’identifiant (ici CODGEO) et on lui demande de transformer le tableau de données en dictionnaire.\n\nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n\n#contrôle\nG.nodes(\"MARS\")\n\nNodeDataView({'13001': False, '13041': False, '13201': True, '13205': True, '13208': True, '13209': True, '13213': True, '13002': False, '13206': True, '13211': True, '13212': True, '13003': False, '13053': False, '13103': False, '13004': False, '13078': False, '13097': False, '13005': False, '13028': False, '13042': False, '13119': False, '13210': True, '13007': False, '13014': False, '13117': False, '13015': False, '13016': False, '13086': False, '13018': False, '13089': False, '13019': False, '13020': False, '13046': False, '13022': False, '13023': False, '13024': False, '13050': False, '13025': False, '13026': False, '13043': False, '13054': False, '13056': False, '13030': False, '13031': False, '13032': False, '13033': False, '13035': False, '13036': False, '13100': False, '13037': False, '13038': False, '13039': False, '13047': False, '13077': False, '13040': False, '13044': False, '13045': False, '13083': False, '13108': False, '13063': False, '13048': False, '13074': False, '13049': False, '13051': False, '13052': False, '13102': False, '13104': False, '13059': False, '13060': False, '13062': False, '13064': False, '13065': False, '13066': False, '13027': False, '13068': False, '13069': False, '13070': False, '13071': False, '13072': False, '13087': False, '13073': False, '13075': False, '13076': False, '13067': False, '13079': False, '13080': False, '13081': False, '13082': False, '13084': False, '13085': False, '13088': False, '13091': False, '13092': False, '13094': False, '13095': False, '13098': False, '13101': False, '13105': False, '13106': False, '13107': False, '13109': False, '13110': False, '13111': False, '13112': False, '13113': False, '13114': False, '13118': False, '13202': True, '13203': True, '13204': True, '13214': True, '13215': True, '13207': True, '13216': True}, data='MARS')\n\n\nPlusieurs moyens permettent de contrôler que l’importation s’est bien déroulée :\n\nafficher l’ordre (nombre de sommets) ;\nafficher la taille (nombre de liens) ;\ncontrôler les caractéristiques du réseau ;\nvisualiser le réseau obtenu.\n\n\nprint(\"Ordre\", nx.number_of_nodes(G), \" sommets\")\nprint(\"Taille\", nx.number_of_edges(G), \" liens\")\nprint(\"Réseau orienté ?\", nx.is_directed(G))\n\n# attribut des liens\nprint(\"attribut des liens : \", list(list(G.edges(data=True))[0][-1].keys()))\n\n# attributs des sommets\nprint(\"attribut des sommets : \", list(list(G.nodes(data=True))[0][-1].keys()))\n\n# visualisation basique\nnx.draw_networkx(G, with_labels=False)\n\nOrdre 114  sommets\nTaille 317  liens\nRéseau orienté ? True\nattribut des liens :  ['weight']\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS']"
  },
  {
    "objectID": "C2_filtrer.html",
    "href": "C2_filtrer.html",
    "title": "2  Filtrer, sélectionner",
    "section": "",
    "text": "La visualisation montre un réseau non connexe. Le morceau de code qui suit décrit les différentes composantes du réseau et extrait la principale composante connexe. Le réseau étant orienté, on cherche une connexité faible (weakly_connected_components) ; si le réseau était non orienté, on utiliserait la fonction connected_components.\nLa logique est souvent similaire : on crée une liste correspondant au résultat ordonné d’une mesure puis on sélectionne des éléments de cette liste. Le numéro 0 entre crochets correspond au premier élément (Python numérote les éléments de 0 à n - 1 et non de 1 à n).\n\n# liste ordonnée des composantes connexes\nCC = sorted(nx.weakly_connected_components(G),\n            key=len,                            # clé de tri - len = longueur\n            reverse=True)                       # ordre décroissant\nprint(\"Nombre de composantes\", len(CC))\n\n# nombre de sommets par composantes\nprint(\"Nombre de sommets par composantes\",\n      [len(c) for c in sorted(nx.weakly_connected_components(G),\n       key=len,\n       reverse=True)])\n\n# sélection de la composante connexe principale\nGD = G.subgraph(CC[0])\n\nNombre de composantes 4\nNombre de sommets par composantes [106, 3, 3, 2]\n\n\nUne version non orientée est créée car certaines mesures imposent un réseau de ce type. La valuation des liens est conservée dans la version non orientée : par défaut, elle ne correspond pas à la somme des intensités entrantes et sortantes. Ici, l’intensité du lien ij dans la version non orientée correspond à l’intensité du lien ij dans la version orientée.\n\n\n# création d'une version non orientée\nGU = nx.to_undirected(GD)\n\nnx.is_weighted(GU)             #True\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  135\n\n\nObtenir une valuation des liens dans le réseau non orienté correspondant à la somme des intensités \\(ij + ji\\) nécessite quelques étapes supplémentaires détaillées dans les lignes ci-dessous.\n\n# créer une copie sans aucun lien\nGU = nx.create_empty_copy(GD, with_data=True)\nGU = nx.to_undirected(GU)\n\n# éviter message \"Frozen graph can't be modified\"\nGU = nx.Graph(GU)\n\n# récupérer liens avec intensité nulle\nGU.add_edges_from(GD.edges(), weight=0)\n\n# pour chaque lien ij + ji\nfor u, v, d in GD.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n\n# contrôle\n\n#a attributs liens et sommets\nlist(list(GU.edges(data=True))[0][-1].keys())\nlist(list(GU.nodes(data=True))[0][-1].keys())\n\n# propriétés du réseau\nnx.is_directed(GU)\nnx.is_connected(GU)\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  634"
  },
  {
    "objectID": "C2_filtrer.html#filtrage",
    "href": "C2_filtrer.html#filtrage",
    "title": "2  Filtrer, sélectionner",
    "section": "2.2 Filtrage",
    "text": "2.2 Filtrage\nLes données sont importées, la plus grande composante connexe a été extraite dans deux versions, une orientée et une non orientée. On peut souhaiter faire des sélections autres, que ce soit sur les sommets ou sur les liens. Deux options sont possibles : supprimer liens ou sommets selon un critère donné (remove_edges_from(), remove_nodes_from) ; sélectionner liens ou sommets selon un critère donné (subgraph()).\nSi je souhaite travailler uniquement sur le cas marseillais :\n\n# filtrage des sommets (1)\n# sélection des sommets satisfaisant la condition\nMars = [n for n, v in G.nodes(data=True) if v['MARS'] == True]  \n\n# création d'un sous-graphe\nGmars = G.subgraph(Mars)\n\n# visualisation\nnx.draw_networkx(Gmars,\n                 pos = nx.kamada_kawai_layout(Gmars),\n                 with_labels=True)\n\n\n\n\nOn obtient le même résultat avec l’opération consistant à supprimer les sommets des communes hors Marseille :\n\n# filtrage des sommets (2)\n# sélection des sommets hors Marseille\nnonmars = [n for n,v in G.nodes(data=True) if v['MARS'] == False] \n\n# copier le réseau de départ\nGmars2 = G\n\n# supprimer les communes hors Marseille\nGmars2.remove_nodes_from(nonmars)\n\n# visualisation\nnx.draw_networkx(Gmars2,\n                 pos = nx.kamada_kawai_layout(Gmars2),\n                 with_labels=True)\n\n\n\n\nSi je souhaite travailler uniquement sur les flux les plus importants :\n\n# filtrer les liens\n# paramètres statistiques\nliens.describe()\n\n# fixer un seuil (ici la médiane)\nseuil = 212\n\n# identifier les liens sous ce seuil, récupérer les identifiants\nlong_edges = list(filter(lambda e: e[2] < seuil, (e for e in G.edges.data('weight'))))\nle_ids = list(e[:2] for e in long_edges)\n\n# créer une copie du réseau de départ\nGsup = G\n\n# supprimer les liens identifiés\nGsup.remove_edges_from(le_ids)\n\n# ordre, taille et visualisation\nprint(\"Nb de sommets : \", nx.number_of_nodes(Gsup))\nprint(\"Nb de liens : \", nx.number_of_edges(Gsup))\n\nnx.draw_networkx(Gsup,\n                 pos = nx.kamada_kawai_layout(Gsup),\n                 with_labels=True)\n\nNb de sommets :  16\nNb de liens :  64\n\n\n\n\n\nLe fait de ne conserver que les liens entraîne la suppression des sommets devenant isolés. Le nombre de liens a très logiquement été divisé par deux dans la mesure où le seuil choisi ici est la médiane.\nSi dans un réseau donné, j’ai des sommets isolés que je souhaite éliminer, j’utilise la fonction remove_nodes_from.\nSoit un réseau aléatoire de 20 sommets contenant des isolés.\n\n# générer un réseau aléatoire avec 2 isolés\nrg = nx.gnp_random_graph(20, 0.05, seed = 1)\nprint(\"Nb de sommets (isolés compris) : \", nx.number_of_nodes(rg))\n\n# liste des sommets avec un degré nul\nisoles = [node for node,degree in dict(rg.degree()).items() if degree < 1]\n\n# suppression des sommets concernés\nrg.remove_nodes_from(isoles)\nprint(\"Nb de sommets  (isolés exclus) : \", nx.number_of_nodes(rg))\n\nNb de sommets (isolés compris) :  20\nNb de sommets  (isolés exclus) :  18"
  },
  {
    "objectID": "C2_filtrer.html#agrégation",
    "href": "C2_filtrer.html#agrégation",
    "title": "2  Filtrer, sélectionner",
    "section": "2.3 Agrégation",
    "text": "2.3 Agrégation\nIl peut être intéressant d’agréger différents sommets. La fonction contracted_nodes prend en argument le réseau étudié et les deux sommets à fusionner, l’option self_loops permet de contrôler la création d’une boucle et l’option copy permet de créer un nouveau réseau sans écraser le premier.\nSi je veux fusionner deux arrondissements marseillais, j’utilise le script suivant. Les lignes suivantes permettent de lister les liens entrants et sortants du sommet résultat de la fusion et de vérifier la présence (ici souhaitée) de la boucle.\n\nGA = nx.contracted_nodes(G, '13215', '13216', self_loops=True, copy=True)\nGA.in_edges('13215')   # liste des liens entrants\nGA.out_edges('13215')  # liste des liens sortants\n\nOutEdgeDataView([('13215', '13213'), ('13215', '13214'), ('13215', '13215')])"
  },
  {
    "objectID": "C3_mesurer.html",
    "href": "C3_mesurer.html",
    "title": "3  Mesures",
    "section": "",
    "text": "Les mesures sont testées sur deux réseaux, l’un orienté (GD) et l’autre non (GU), correspondant à la plus grande composante connexe. Lorsque la valuation et l’orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n’est pas abordé.\nNetworkX propose de nombreuses mesures et méthodes issues de la théorie des graphes au sens strict (centre, barycentre, rayon, etc.) et de l’analyse des flots dans les réseaux (optimisation) ; toutes ne sont pas évoquées ici et je me suis intéressé en priorité aux méthodes me semblant - peut-être à tort - les plus utilisées en sciences sociales."
  },
  {
    "objectID": "C3_mesurer.html#mesures-globales",
    "href": "C3_mesurer.html#mesures-globales",
    "title": "3  Mesures",
    "section": "3.1 Mesures globales",
    "text": "3.1 Mesures globales\nDans les pages précédentes, on a déjà vu comment afficher l’ordre et la taille du réseau. La densité s’obtient avec la fonction density, le diamètre avec la fonction diameter.\n\n# ordre et taille\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GD), \" sommets\")\nprint(\"nombre de liens - orienté (taille) : \", nx.number_of_edges(GD), \" liens\")\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GU), \" sommets\")\nprint(\"nombre de liens - non orienté (taille) : \", nx.number_of_edges(GU), \" liens\")\n\n# densité et diamètre\nprint(\"densité (orienté) : \", round(nx.density(GD), 2))\nprint(\"densité (non orienté) :\", round(nx.density(GU), 2))\n# print(\"diamètre (non orienté et connexe) : \", nx.diameter(GD))\n\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - orienté (taille) :  312  liens\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - non orienté (taille) :  250  liens\ndensité (orienté) :  0.03\ndensité (non orienté) : 0.04\n\n\nSi on cherche à mesurer le diamètre sur un réseau orienté non fortement connexe, on obtient le message d’erreur suivant : “Found infinite path length because the digraph is not strongly connected”.\nMesures directement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance entre le(s) sommet(s) ayant une excentricité minimale et tout autre sommet du graphe (cf infra les mesures locales) et à l’ensemble de sommets minimisant la fonction \\(\\sum_{u \\in V(G)} d_G(u, v)\\), \\(d_G(u, v)\\) étant la distance (topologique ou valuée) entre deux sommets \\(u\\) et \\(v\\) de \\(G\\).\n\n# rayon\nprint(\"rayon : \", nx.radius(GU))\n\n# barycentre\nprint(\"barycentre : \", nx.barycenter(GU))\nprint(\"barycentre (valué) : \", nx.barycenter(GU, weight='weight'))\n\nrayon :  4\nbarycentre :  ['13001']\nbarycentre (valué) :  ['13001']\n\n\nLa liste du ou des sommets centraux s’obtient avec center, la liste des sommets périphériques avec periphery. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.\n\nprint(\"Sommets centraux : \", nx.center(GU))\nprint(\"Sommets périphériques : \", nx.periphery(GU))\n\nSommets centraux :  ['13001']\nSommets périphériques :  ['13083', '13076']\n\n\nComme toutes les mesures fondées sur la recherche de plus courts chemins (diamètre, rayon, etc.), ces fonctions supposent soit un réseau non orienté, soit un réseau orienté fortement connexe.\nIl est possible de connaître l’ensemble des isthmes et des points d’articulation présents dans un réseau.\n\n# isthmes et points d'articulation (réseau connexe)\n# nombre et liste des isthmes\nprint(\"nb isthmes : \", len(list(nx.bridges(GU))))\nprint(\"isthmes : \",list(nx.bridges(GU)))\n\n# nombre et liste des points d'articulation\nprint(\"nb points d'articulation : \", len(list(nx.articulation_points(GU))))\nprint(\"points d'articulation : \", list(nx.articulation_points(GU)))\n\nnb isthmes :  32\nisthmes :  [('13001', '13004'), ('13001', '13015'), ('13001', '13019'), ('13001', '13025'), ('13001', '13032'), ('13001', '13095'), ('13001', '13107'), ('13001', '13109'), ('13001', '13110'), ('13001', '13111'), ('13001', '13113'), ('13213', '13075'), ('13103', '13035'), ('13103', '13044'), ('13103', '13049'), ('13004', '13078'), ('13004', '13038'), ('13004', '13108'), ('13097', '13068'), ('13005', '13031'), ('13028', '13023'), ('13020', '13046'), ('13046', '13073'), ('13046', '13101'), ('13024', '13050'), ('13054', '13088'), ('13056', '13104'), ('13045', '13083'), ('13045', '13108'), ('13108', '13094'), ('13076', '13067'), ('13067', '13105')]\nnb points d'articulation :  15\npoints d'articulation :  ['13046', '13028', '13005', '13054', '13103', '13050', '13067', '13105', '13056', '13213', '13004', '13097', '13045', '13108', '13001']\n\n\nL’indice de Wiener, issu de l’étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets (équivaut à l’indice de dispersion de Shimbel parfois utilisé par les géographes des transports). Le réseau orienté n’étant pas fortement connexe, le résultat est une distance infinie (inf). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.\n\n# indice de wiener (somme des pcc)\nprint(\"Indice de Wiener (orienté) : \", nx.wiener_index(GD))     # distance topologique\nprint(\"Indice de Wiener (non orienté) : \", nx.wiener_index(GU)) # distance topologique\nprint(\"Indice de Wiener (non orienté, valué) : \", nx.wiener_index(GU, 'weight'))  # somme des intensités\n\nIndice de Wiener (orienté) :  inf\nIndice de Wiener (non orienté) :  15228.0\nIndice de Wiener (non orienté, valué) :  3800738.0\n\n\nMesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l’assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau disassortatif, les sommets ayant un degré faible tendent à être voisins des sommets ayant un degré élevé et inversement) et 1 (réseau assortatif, les sommets ayant un degré faible sont voisins de sommets ayant un degré faible, les sommets ayant un degré élevé sont voisins de sommets ayant un degré élevé). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.\n\n# assortativité (degré par défaut)\n# réseau orienté - 4 options possibles\nprint(\"assortativité in-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='in'),3))\n\nprint(\"assortativité in-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='out'),3))\n\nprint(\"assortativité out-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='in'),3))\n\nprint(\"assortativité out-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='out'),3))\n\n# réseau non orienté\nprint(\"assortativité globale (non orienté) : \", \n      round(nx.degree_assortativity_coefficient(GU),3))\n\n# assortativité selon un critère autre que le degré\nprint(round(nx.numeric_assortativity_coefficient(GD, \"MARS\"),3))\n\nassortativité in-in :  -0.105\nassortativité in-out :  0.262\nassortativité out-in :  -0.198\nassortativité out-out :  0.485\nassortativité globale (non orienté) :  -0.234\n0.707\n\n\nMesure relativement proche (voir la page wikipedia), le rich club coefficient s’obtient avec la fonction… rich_club_coefficient ; elle peut être utilisée uniquement sur des réseaux non orientés et ne tient pas compte des éventuelles boucles, liens multiples ou intensité des liens. La fonction renvoie une valeur par degré (rc coefficient des sommets de degré 1, de degré 2, etc.).\n\n# rich-club coefficient\nprint(\"rich-club coefficient : \", nx.rich_club_coefficient(GU, normalized=True, seed=42))\n\nrich-club coefficient :  {0: 1.0, 1: 0.9955156950672646, 2: 1.0119047619047619, 3: 1.0546875, 4: 1.0677966101694916, 5: 1.0727272727272728, 6: 1.153846153846154, 7: 1.168831168831169, 8: 1.2222222222222223, 9: 1.303030303030303, 10: 1.320754716981132, 11: 1.25, 12: 1.2000000000000002, 13: 1.1052631578947367, 14: 1.1111111111111112, 15: 1.3333333333333335, 16: 1.5, 17: 1.0}\n\n\nLes mesures “globales” fondées sur des mesures “locales” (degré ou transitivité moyenne par exemple) sont abordées dans la section suivante."
  }
]