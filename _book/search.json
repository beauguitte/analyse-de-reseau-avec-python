[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse de réseau avec Python et NetworkX",
    "section": "",
    "text": "Je n’utilise pas l’écriture épicène, j’écris le plus souvent au féminin et utilise l’accord de proximité.↩︎"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "See Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, D. E. (1984). Literate programming. Comput. J., 27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Beauguitte, L. (2023). L’analyse de réseau en sciences\nsociales. Petit guide pratique. Groupe fmr. https://hal.science/hal-04052709"
  },
  {
    "objectID": "C4_partitions.html#blockmodel",
    "href": "C4_partitions.html#blockmodel",
    "title": "4  Partitions",
    "section": "4.2 Blockmodel",
    "text": "4.2 Blockmodel"
  },
  {
    "objectID": "C4_partitions.html#détection-de-communautés",
    "href": "C4_partitions.html#détection-de-communautés",
    "title": "4  Partitions",
    "section": "4.3 Détection de communautés",
    "text": "4.3 Détection de communautés"
  },
  {
    "objectID": "C3_mesurer.html#mesures-locales",
    "href": "C3_mesurer.html#mesures-locales",
    "title": "3  Mesures",
    "section": "3.2 Mesures locales",
    "text": "3.2 Mesures locales\nDegré : degree et degree_centrality, ou_degree et in_degree."
  },
  {
    "objectID": "conclusion.html#avec-python",
    "href": "conclusion.html#avec-python",
    "title": "7  Pour aller plus loin",
    "section": "7.2 Avec Python",
    "text": "7.2 Avec Python"
  },
  {
    "objectID": "C1_importer.html",
    "href": "C1_importer.html",
    "title": "1  Importer ses données",
    "section": "",
    "text": "La table som_d13.csv contient les attributs suivants :\n\nCODGEO : code INSEE de la commune ;\nP19_POP : population résidente en 2019 (entiers) ;\nSUPERF : superficie (flottants) ;\nSUP_QUALI : superficie inférieure ou supérieure à la moyenne départementale (chaîne de caractères). Des données ont été volontairement supprimés pour voir comment gérer les données manquantes ;\nNOM : nom de la commune ;\nMARS : variable booléenne permettant de savoir si la commune est un arrondissement de Marseille (1) ou non (0).\n\nLa table liens_d13.csv contient les attributs suivants :\n\nOrigine : code INSEE de la commune de départ ;\nArrivee : code INSEE de la commune d’arrivée ;\nweight : flux d’élèves entre communes (flux > 100).\n\nCes deux fichiers encodés en utf-8 permettent de créer un réseau simple, orienté et valué. Les réseaux autres (bimodaux, multiplexes, avec boucles) ne sont pas évoqués dans ce document.\nPour l’importation et la manipulation des données, soit vous savez utiliser Python et vous n’avez pas besoin de lire les paragraphes qui suivent, soit vous débutez en Python et utiliser le module pandas est recommmandé.\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\n\nAvant de transformer ces tables en un réseau, il est prudent de contrôler le typage par défaut qu’a choisi pandas lors de l’importation avec la fonction dtypes. Il faut en effet que les codes INSEE soient considérés comme des chaînes de caractères (str) et non comme des entiers (int64), et que la variable MARS soit considérée comme une variable booléenne (bool).\n\nprint(sommets.dtypes)\nprint(liens.dtypes)\n\nCODGEO         int64\nP19_POP        int64\nSUPERF       float64\nSUP_QUALI     object\nNOM           object\nMARS           int64\ndtype: object\nOrigine    int64\nArrivee    int64\nweight     int64\ndtype: object\n\n\nLes lignes ci-dessous permettent de typer correctement les données.\n\n# typage des variables\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\n\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\n\nLa syntaxe pour créer un réseau orienté à partir d’une liste de liens est relativement simple. On précise quelle est la colonne des origines, celle des destinations, s’il existe une valuation des liens et si le graphe est orienté.\nPour que le réseau soit considéré comme valué, la colonne des intensités doit s’appeler weight ; il n’y a pas de contrainte particulière concernant les noms de colonnes correspondant aux sommets. Si le réseau est non orienté, on utilise la fonction Graph().\n\nG = nx.from_pandas_edgelist(liens,                     # data.frame des liens\n                            source = \"Origine\",        # nom de la colonne origine\n                            target = \"Arrivee\",        # nom de la colonne destination\n                            edge_attr=\"weight\",        # attribut poids pour un réseau valué\n                            create_using=nx.DiGraph()) # création d'un réseau orienté\n\nLa gestion des attributs des sommets est un tout petit peu plus complexe et la documentation du module n’aide pas vraiment. La solution la plus simple, trouvée en ligne à cette adresse, est d’utiliser la fonction set_index du module pandas. On crée un objet correspondant aux attributs des sommets, on indique quel est l’identifiant (ici CODGEO) et on lui demande de transformer le tableau de données en dictionnaire.\n\nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n\n#contrôle\nG.nodes(\"MARS\")\n\nNodeDataView({'13001': False, '13041': False, '13201': True, '13205': True, '13208': True, '13209': True, '13213': True, '13002': False, '13206': True, '13211': True, '13212': True, '13003': False, '13053': False, '13103': False, '13004': False, '13078': False, '13097': False, '13005': False, '13028': False, '13042': False, '13119': False, '13210': True, '13007': False, '13014': False, '13117': False, '13015': False, '13016': False, '13086': False, '13018': False, '13089': False, '13019': False, '13020': False, '13046': False, '13022': False, '13023': False, '13024': False, '13050': False, '13025': False, '13026': False, '13043': False, '13054': False, '13056': False, '13030': False, '13031': False, '13032': False, '13033': False, '13035': False, '13036': False, '13100': False, '13037': False, '13038': False, '13039': False, '13047': False, '13077': False, '13040': False, '13044': False, '13045': False, '13083': False, '13108': False, '13063': False, '13048': False, '13074': False, '13049': False, '13051': False, '13052': False, '13102': False, '13104': False, '13059': False, '13060': False, '13062': False, '13064': False, '13065': False, '13066': False, '13027': False, '13068': False, '13069': False, '13070': False, '13071': False, '13072': False, '13087': False, '13073': False, '13075': False, '13076': False, '13067': False, '13079': False, '13080': False, '13081': False, '13082': False, '13084': False, '13085': False, '13088': False, '13091': False, '13092': False, '13094': False, '13095': False, '13098': False, '13101': False, '13105': False, '13106': False, '13107': False, '13109': False, '13110': False, '13111': False, '13112': False, '13113': False, '13114': False, '13118': False, '13202': True, '13203': True, '13204': True, '13214': True, '13215': True, '13207': True, '13216': True}, data='MARS')\n\n\nPlusieurs moyens permettent de contrôler que l’importation s’est bien déroulée :\n\nafficher l’ordre (nombre de sommets) ;\nafficher la taille (nombre de liens) ;\ncontrôler les caractéristiques du réseau ;\nvisualiser le réseau obtenu.\n\n\nprint(\"Ordre\", nx.number_of_nodes(G), \" sommets\")\nprint(\"Taille\", nx.number_of_edges(G), \" liens\")\nprint(\"Réseau orienté ?\", nx.is_directed(G))\n\n# attribut des liens\nprint(\"attribut des liens : \", list(list(G.edges(data=True))[0][-1].keys()))\n\n# attributs des sommets\nprint(\"attribut des sommets : \", list(list(G.nodes(data=True))[0][-1].keys()))\n\n# visualisation basique\nnx.draw(G, with_labels=False)\n\nOrdre 114  sommets\nTaille 317  liens\nRéseau orienté ? True\nattribut des liens :  ['weight']\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS']"
  },
  {
    "objectID": "C2_filtrer.html",
    "href": "C2_filtrer.html",
    "title": "2  Filtrer, sélectionner",
    "section": "",
    "text": "La visualisation montre un réseau non connexe. Le morceau de code qui suit décrit les différentes composantes du réseau et extrait la principale composante connexe. Le réseau étant orienté, on cherche une connexité faible (weakly_connected_components) ; si le réseau était non orienté, on utiliserait la fonction connected_components.\nLa logique est souvent similaire : on crée une liste correspondant au résultat ordonné d’une mesure puis on sélectionne des éléments de cette liste. Le numéro 0 entre crochets correspond au premier élément (Python numérote les éléments de 0 à n et non de 1 à n).\n\n# liste ordonnée des composantes connexes\nCC = sorted(nx.weakly_connected_components(G),\n            key=len,                            # clé de tri - len = longueur\n            reverse=True)                       # ordre décroissant\nprint(\"Nombre de composantes\", len(CC))\n\n# nombre de sommets par composantes\nprint(\"Nombre de sommets par composantes\",\n      [len(c) for c in sorted(nx.weakly_connected_components(G),\n       key=len,\n       reverse=True)])\n\n# sélection de la composante connexe principale\nG0 = G.subgraph(CC[0])\n\nNombre de composantes 4\nNombre de sommets par composantes [106, 3, 3, 2]\n\n\nUne version non orientée est créée car certaines mesures imposent un réseau de ce type. La valuation des liens est conservée dans la version non orientée : par défaut, elle ne correspond pas à la somme des intensités entrantes et sortantes. Ici, l’intensité du lien ij dans la version non orientée correspond à l’intensité du lien ij dans la version orientée.\n\n\n# création d'une version non orientée\nG0u = nx.to_undirected(G0)\n\nnx.is_weighted(G0u)             #True\n\nprint(\"lien ij :\", G0[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", G0[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", G0u[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  135\n\n\nObtenir une valuation des liens dans le réseau non orienté correspondant à la somme des intensités \\(ij + ji\\) nécessite quelques étapes supplémentaires détaillées dans les lignes ci-dessous.\n\n# créer une copie sans aucun lien\nGU = nx.create_empty_copy(G, with_data=True)\nGU = nx.to_undirected(GU)\n\n# éviter message \"Frozen graph can't be modified\"\nGU = nx.Graph(GU)\n\n# récupérer liens avec intensité nulle\nGU.add_edges_from(G.edges(), weight=0)\n\n# pour chaque lien ij + ji\nfor u, v, d in G.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n\n# contrôle\n\n#a attributs liens et sommets\nlist(list(GU.edges(data=True))[0][-1].keys())\nlist(list(GU.nodes(data=True))[0][-1].keys())\n\n# propriétés du réseau\nnx.is_directed(GU)\nnx.is_connected(GU)\n\nprint(\"lien ij :\", G[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", G[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  634"
  },
  {
    "objectID": "C2_filtrer.html#filtrage",
    "href": "C2_filtrer.html#filtrage",
    "title": "2  Filtrer, sélectionner",
    "section": "2.2 Filtrage",
    "text": "2.2 Filtrage\nLes données sont importées, la plus grande composante connexe a été extraite. On peut souhaiter faire des sélections autres, que ce soit sur les sommets ou sur les liens. Deux options sont possibles : supprimer liens ou sommets selon un critère donné (remove_edges_from(), remove_nodes_from) ; sélectionner liens ou sommets selon un critère donné (subgraph()).\nSi je souhaite travailler uniquement sur le cas marseillais1 :\n\n# filtrage des sommets (1)\n# sélection des sommets satisfaisant la condition\n#Mars = [n for n,v in G.nodes(data=True) if v['MARS'] == True]  \n\n# création d'un sous-graphe\n#Gmars = G.subgraph(Mars)\n\n# visualisation\n#nx.draw_kamada_kawai(Gmars, with_labels=True)\n\nOn obtient le même résultat avec l’opération consistant à supprimer les sommets des communes hors Marseille :\n\n# filtrage des sommets (2)\n# sélection des sommets hors Marseille\n#nonmars = [n for n,v in G.nodes(data=True) if v['MARS'] == False] \n\n# copier le réseau de départ\n#Gmars2 = G\n\n# supprimer les communes hors Marseille\n#Gmars2.remove_nodes_from(nonmars)\n\n# visualisation\n#nx.draw_kamada_kawai(Gmars2,\n#                     with_labels=True)\n\nSi je souhaite travailler uniquement sur les flux les plus importants :\n\n# filtrer les liens\n# paramètres statistiques\nliens.describe()\n\n# fixer un seuil (ici la médiane)\nseuil = 212\n\n# identifier les liens sous ce seuil, récupérer les identifiants\nlong_edges = list(filter(lambda e: e[2] < seuil, (e for e in G.edges.data('weight'))))\nle_ids = list(e[:2] for e in long_edges)\n\n# créer une copie du réseau de départ\nGsup = G\n\n# supprimer les liens identifiés\nGsup.remove_edges_from(le_ids)\n\n# ordre, taille et visualisation\nprint(\"Nb de sommets : \", nx.number_of_nodes(Gsup))\nprint(\"Nb de liens : \", nx.number_of_edges(Gsup))\n\nnx.draw_kamada_kawai(Gsup, with_labels=True)\n\nNb de sommets :  114\nNb de liens :  159\n\n\n\n\n\nLe fait de ne conserver que les liens entraîne la suppression des sommets devenant isolés. Le nombre de liens a très logiquement été divisé par deux dans la mesure où le seuil choisi ici est la médiane.\nSi dans un réseau donné, j’ai des sommets isolés que je souhaite éliminer, j’utilise la fonction remove_nodes_from.\nSoit un réseau aléatoire de 20 sommets contenant des isolés.\n\n# générer un réseau aléatoire avec 2 isolés\nrg = nx.gnp_random_graph(20, 0.05, seed = 1)\nprint(\"Nb de sommets (isolés compris) : \", nx.number_of_nodes(rg))\n\n# liste des sommets avec un degré nul\nisoles = [node for node,degree in dict(rg.degree()).items() if degree < 1]\n\n# suppression des sommets concernés\nrg.remove_nodes_from(isoles)\nprint(\"Nb de sommets  (isolés exclus) : \", nx.number_of_nodes(rg))\n\nNb de sommets (isolés compris) :  20\nNb de sommets  (isolés exclus) :  18"
  },
  {
    "objectID": "C2_filtrer.html#agrégation",
    "href": "C2_filtrer.html#agrégation",
    "title": "2  Filtrer, sélectionner",
    "section": "2.3 Agrégation",
    "text": "2.3 Agrégation\nIl peut être intéressant d’agréger différents sommets. La fonction contracted_nodes prend en argument le réseau étudié et les deux sommets à fusionner, l’option self_loops permet de contrôler la création d’une boucle et l’option copy permet de créer un nouveau réseau sans écraser le premier.\nSi je veux fusionner deux arrondissements marseillais, j’utilise le script suivant. Les lignes suivantes permettent de lister les liens entrants et sortants du sommet résultat de la fusion et de vérifier la présence (ici souhaitée) de la boucle.\n\nGA = nx.contracted_nodes(G, '13215', '13216', self_loops=True, copy=True)\nGA.in_edges('13215')   # liste des liens entrants\nGA.out_edges('13215')  # liste des liens sortants\n\nOutEdgeDataView([('13215', '13001'), ('13215', '13071'), ('13215', '13213'), ('13215', '13214'), ('13215', '13215')])\n\n\nAutre fonction d’agrégation, snap_aggregation agrège l’ensemble des sommets voisins partageant une même modalité. Le script ci-dessous crée un réseau où un sommet agrégé correspond à l’un des cas de figures suivants :\n\ncommunes hors Marseille liées entre elles et non liées à un arrondissement marseillais ;\ncommunes hors Marseille liées entre elles et liées à un arrondissement marseillais ;\narrondissements marseillais liés entre eux et non liés à des communes extérieures ;\narrondissements marseillais liés entre eux et liés à des communes extérieures.\n\nDans la mesure où il ne semble pas aisément possible de savoir quels sommets agrégés forment les super sommets (en tout cas, je n’ai pas encore trouvé l’information), peut-être est-il plus prudent d’effectuer ce type de manipulations en amont, sur le tableau de données initial.\n\n# node_attributes = ('MARS',)\n# GA = nx.snap_aggregation(G, node_attributes = node_attributes)  \n# print(\"Nb de sommets : \", nx.number_of_nodes(GA))\n# print(\"Nb de liens : \", nx.number_of_edges(GA))\n# nx.draw_kamada_kawai(GA, with_labels=False)"
  },
  {
    "objectID": "C3_mesurer.html",
    "href": "C3_mesurer.html",
    "title": "3  Mesures",
    "section": "",
    "text": "Les mesures sont testées sur deux réseaux, l’un orienté (GD) et l’autre non (GU), correspondant à la plus grande composante connexe. Lorsque la valuation et l’orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n’est pas abordé."
  },
  {
    "objectID": "C3_mesurer.html#mesures-globales",
    "href": "C3_mesurer.html#mesures-globales",
    "title": "3  Mesures",
    "section": "3.1 Mesures globales",
    "text": "3.1 Mesures globales\nDans les pages précédentes, on a déjà vu comment afficher l’ordre et la taille du réseau. La densité s’obtient avec la fonction density, le diamètre avec la fonction diameter. Lorsque les liens sont porteurs d’une intensité, il est possible de calculer une version pondérée du diamètre (intensité minimale entre les sommets les plus éloignés). Cela a un sens si la valuation peut être interprétée comme une distance (ce qui n’est pas le cas ici).\n\n# ordre et taille\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GD), \" sommets\")\nprint(\"nombre de liens - orienté (taille) : \", nx.number_of_edges(GD), \" liens\")\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GU), \" sommets\")\nprint(\"nombre de liens - non orienté (taille) : \", nx.number_of_edges(GU), \" liens\")\n\n# densité et diamètre\nprint(\"densité (orienté) : \", round(nx.density(GD), 2))\nprint(\"densité (non orienté) :\", round(nx.density(GU), 2))\nprint(\"Diamètre (non orienté et connexe) : \", nx.diameter(GU))\nprint(\"Diamètre (non orienté, valué) : \", nx.diameter(GU, weight = \"weight\"))\n\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - orienté (taille) :  312  liens\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - non orienté (taille) :  250  liens\ndensité (orienté) :  0.03\ndensité (non orienté) : 0.04\nDiamètre (non orienté et connexe) :  8\n\n\nDiamètre (non orienté, valué) :  2004\n\n\nL’indice de Wiener, issu de l’étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets. Le réseau orienté n’étant pas fortement connexe, le résultat est une distance infinie (inf). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.\n\n# indice de wiener (somme des pcc)\nprint(\"Indice de Wiener (orienté) : \", nx.wiener_index(GD))     # distance topologique\nprint(\"Indice de Wiener (non orienté) : \", nx.wiener_index(GU)) # distance topologique\nprint(\"Indice de Wiener (non orienté, valué) : \", nx.wiener_index(GU, 'weight'))  # somme des intensités\n\nIndice de Wiener (orienté) :  inf\nIndice de Wiener (non orienté) :  15228.0\nIndice de Wiener (non orienté, valué) :  3800738.0\n\n\nMesures dirextement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance la plus grande entre deux sommets quelconques d’un graphe (excentricité minimale - cf infra les mesures locales) et à l’ensemble de sommets minimisant la fonction \\(\\sum_{u \\in V(G)} d_G(u, v)\\), \\(d_G(u, v)\\) étant la distance (topologique ou valuée) entre deux sommets \\(u\\) et \\(v\\) de \\(G\\).\n\nprint(\"rayon : \", nx.radius(GU))\n\n# barycentre\nprint(\"barycentre : \", nx.barycenter(GU))\nprint(\"barycentre (valué) : \", nx.barycenter(GU, weight='weight'))\n\nrayon :  4\nbarycentre :  ['13001']\nbarycentre (valué) :  ['13001']\n\n\nLa liste du ou des sommets centraux s’obtient avec center, la liste des sommets périphériques avec periphery. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.\n\nprint(\"Sommets centraux : \", nx.center(GU))\nprint(\"Sommets périphériques : \", nx.periphery(GU))\n\nSommets centraux :  ['13001']\nSommets périphériques :  ['13083', '13076']\n\n\nIl est possible de connaître l’ensemble des isthmes et des points d’articulation présents dans un réseau.\n\n# isthmes et points d'articulation (réseau connexe)\n# nombre d'isthmes\nprint(\"nb isthmes : \", len(list(nx.bridges(GU))))\n\n# liste des isthmes\nprint(\"isthmes : \",list(nx.bridges(GU)))\n\n# nombre de points d'articulation\nprint(\"nb points d'articulation : \", len(list(nx.articulation_points(GU))))\n\n# liste des points d'articulation\nprint(\"points d'articulation : \", list(nx.articulation_points(GU)))\n\nnb isthmes :  32\nisthmes :  [('13001', '13004'), ('13001', '13015'), ('13001', '13019'), ('13001', '13025'), ('13001', '13032'), ('13001', '13095'), ('13001', '13107'), ('13001', '13109'), ('13001', '13110'), ('13001', '13111'), ('13001', '13113'), ('13213', '13075'), ('13103', '13035'), ('13103', '13044'), ('13103', '13049'), ('13004', '13078'), ('13004', '13038'), ('13004', '13108'), ('13097', '13068'), ('13005', '13031'), ('13028', '13023'), ('13020', '13046'), ('13046', '13073'), ('13046', '13101'), ('13024', '13050'), ('13054', '13088'), ('13056', '13104'), ('13045', '13083'), ('13045', '13108'), ('13108', '13094'), ('13076', '13067'), ('13067', '13105')]\nnb points d'articulation :  15\npoints d'articulation :  ['13046', '13028', '13005', '13054', '13103', '13050', '13067', '13105', '13056', '13213', '13004', '13097', '13045', '13108', '13001']\n\n\nMesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l’assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau dissassortatif) et 1 (réseau assortatif). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.\n\n# assortativité (degré par défaut)\n# orienté\nprint(\"assortativité in-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='in'),3))\n\nprint(\"assortativité in-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='out'),3))\n\nprint(\"assortativité out-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='in'),3))\n\nprint(\"assortativité out-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='out'),3))\n\n# non orienté\nprint(\"assortativité globale (non orienté) : \", \n      round(nx.degree_assortativity_coefficient(GU),3))\n\n# selon un critère autre que le degré (erreur...)\n#print(round(nx.numeric_assortativity_coefficient(GD, \"MARS\"),3))\n\nassortativité in-in :  -0.105\nassortativité in-out :  0.262\nassortativité out-in :  -0.198\nassortativité out-out :  0.485\nassortativité globale (non orienté) :  -0.234"
  }
]