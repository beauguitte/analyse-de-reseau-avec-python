{"title":"Visualiser ses données","markdown":{"headingText":"Visualiser ses données","containsRefs":false,"markdown":"\n```{python}\n#| echo: false\nimport pandas as pd                # manipulation de tableaux\nimport networkx as nx              # analyse de réseau\nimport numpy as np                 # statistiques\nimport matplotlib.pyplot as plt    # visualisation\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\nG = nx.from_pandas_edgelist(liens,source = \"Origine\",target = \"Arrivee\", edge_attr=\"weight\",create_using=nx.DiGraph()) \nCC = sorted(nx.weakly_connected_components(G),key=len,reverse=True) \nGD = G.subgraph(CC[0])\nGU = nx.create_empty_copy(GD, with_data=True)\nGU = nx.to_undirected(GU)\nlist(list(GU.nodes(data=True))[0][-1].keys())\nGU = nx.Graph(GU)\nGU.add_edges_from(GD.edges(), weight=0)\nfor u, v, d in GD.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n```\n\nDifférents algorithmes de placement des sommets sont disponibles, certaines étant adaptés à des types précis de réseaux (`bipartite_layout`, `planar_layout`, `multipartite_layout`).\n<!-- bipartite : v2 -->\n\n```{python}\n#graphe de Petersen\n#pour les plus curieuses : https://fr.wikipedia.org/wiki/Graphe_de_Petersen\nG = nx.petersen_graph()\n\n# algorithmes de visualisation\n# juxtaposer des fenêtres\nfig, ax = plt.subplots(3, 2, figsize = (9,8)) # 3 lignes, 2 colonnes\nnx.draw_networkx(G, ax = ax[0,0])             # ax[0,0] : à placer sur la première ligne, première colonne\nax[0,0].set_title('Default (Spring)')         # titre de la figure\nnx.draw_networkx(G, pos = nx.random_layout(G), ax = ax[0,1])\nax[0,1].set_title('Random layout')\nnx.draw_networkx(G, pos = nx.shell_layout(G), ax = ax[1,0])\nax[1,0].set_title('Shell layout')\nnx.draw_networkx(G, pos = nx.spectral_layout(G), ax = ax[1,1])\nax[1,1].set_title('Spectral layout')\nnx.draw_networkx(G, pos = nx.kamada_kawai_layout(G), ax = ax[2,0])\nax[2,0].set_title('Kamada Kawai layout')\nnx.draw_networkx(G, pos = nx.spiral_layout(G), ax = ax[2,1])\nax[2,1].set_title('Spiral layout')\n```\n\nIl est évidemment possible de modifier l'apparence des sommets et des liens et, par exemple, de faire varier la taille ou la couleur en fonction d'un attribut. Il est souvent nécessaire de créer au préalable un dictionnaire permettant de faire varier le paramètre graphique voulu selon un indicateur donné, par exemple faire varier la taille des sommets selon le degré.\n\nLes exemples ci-dessous ne prétendent pas à l'exhaustivité mais illustrent l'utilisation de quelques paramètres graphiques d'usage courant.\n\n```{python}\n# création du dictionnaire pour les degrés\nd = dict(GU.degree)\n\n# création d'une liste des intensités\nweights = [GU[u][v]['weight'] for u,v in GU.edges]\n\nnx.draw_networkx(GU,\n               pos = nx.spring_layout(GU),  # algorithme de placement\n               node_color = 'orange',  # couleur des sommets\n               alpha = 0.8,            # transparence\n               nodelist= d.keys(),     # liste des sommets      \n               node_size = [v * 20 for v in d.values()], # taille des sommets\n               edge_cmap=plt.cm.Blues, # palette de couleurs\n               edge_color = weights,   # couleur des liens\n               with_labels=False,      # affichage des labels\n               width=4)                # épaisseur des liens\n\n```\n\n```{python}\n# faire varier teinte et épaisseur des liens\n# diviser les intensités par 100\n\nweigh2 = [i/100 for i in weights]\n\nnx.draw_networkx(GU,\n               pos = nx.kamada_kawai_layout(GU),\n               node_color = 'orange', \n               alpha = 0.8,\n               nodelist= d.keys(), \n               node_size = [v * 20 for v in d.values()], \n               edge_cmap=plt.cm.Blues,\n               edge_color = weights,\n               with_labels = False,\n               width=weigh2)\n```\n\nSi on souhaite produire plusieurs figures avec la même apparence, le plus simple est de définir au préalable les options de visualisation puis de les appeler.\n\n```{python}\n# définir les options de visualisation\noptions = {\n      'node_color' : 'orange',\n      'node_size'  : 40, \n      'edge_color' : 'blue',\n      'width' : 1,\n      'alpha' : 0.8,\n      'with_labels': False\n    }\n\n# visualiser\nnx.draw_networkx(G, **options)\n```\n\nOn trouve en ligne des exemples permettant de tester d'autres types de visualisation (matrice, edge-bundling, etc.). Ces points seront évoqués dans une version ultérieure de ce tutoriel. \n\n<!-- https://towardsdatascience.com/python-interactive-network-visualization-using-networkx-plotly-and-dash-e44749161ed7 -->\n<!-- https://trenton3983.github.io/files/projects/2020-05-21_intro_to_network_analysis_in_python/2020-05-21_intro_to_network_analysis_in_python.html -->"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"C6_visualiser.html"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"C6_visualiser.pdf"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{}}}}}