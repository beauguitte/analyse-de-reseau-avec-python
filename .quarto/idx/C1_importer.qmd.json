{"title":"Importer ses données","markdown":{"headingText":"Importer ses données","containsRefs":false,"markdown":"\nLe jeu de données utilisé tout au long de ce document est l'extrait concernant les Bouches-du-Rhône de la [base 2017 des mobilités scolaires intercommunales de l'INSEE](https://www.insee.fr/fr/statistiques/4509360).\n\nLa table **som_d13.csv** contient les attributs suivants :\n\n-   **CODGEO** : code INSEE de la commune ;\n-   **P19_POP** : population résidente en 2019 (entiers) ;\n-   **SUPERF** : superficie (flottants) ;\n-   **SUP_QUALI** : superficie inférieure ou supérieure à la moyenne départementale (chaîne de caractères). Des données ont été volontairement supprimés pour voir comment gérer les données manquantes ;\n-   **NOM** : nom de la commune ;\n-   **MARS** : variable booléenne permettant de savoir si la commune est un arrondissement de Marseille (1) ou non (0).\n\nLa table **liens_d13.csv** contient les attributs suivants :\n\n-   **Origine** : code INSEE de la commune de départ ;\n-   **Arrivee** : code INSEE de la commune d'arrivée ;\n-   **weight** : flux d'élèves entre communes (flux \\> 100).\n\nCes deux fichiers encodés en utf-8 permettent de créer un réseau simple, orienté et valué. Les réseaux autres (bimodaux, multiplexes, avec boucles) ne sont pas évoqués dans ce document.\n\nPour l'importation et la manipulation des données, soit vous savez utiliser Python et vous n'avez pas besoin de lire les paragraphes qui suivent, soit vous débutez en Python et utiliser le module `pandas` est recommmandé.\n\n```{python}\n#| echo: false\nimport pandas as pd                # manipulation de tableaux\nimport networkx as nx              # analyse de réseau\nimport numpy as np                 # statistiques\nimport matplotlib.pyplot as plt    # visualisation\n```\n\n```{python}\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\n\n```\n\nAvant de transformer ces tables en un réseau, il est prudent de contrôler le typage par défaut qu'a choisi `pandas` lors de l'importation avec la fonction `dtypes`. Il faut en effet que les codes INSEE soient considérés comme des chaînes de caractères (`str`) et non comme des entiers (`int64`), et que la variable **MARS** soit considérée comme une variable booléenne (`bool`).\n\n```{python}\nprint(sommets.dtypes)\nprint(liens.dtypes)\n```\n\nLes lignes ci-dessous permettent de typer correctement les données.\n\n```{python}\n# typage des variables\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\n\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\n\n```\n\nLa syntaxe pour créer un réseau orienté à partir d'une liste de liens est relativement simple. On précise quelle est la colonne des origines, celle des destinations, s'il existe une valuation des liens et si le graphe est orienté.\n\nPour que le réseau soit considéré comme valué, la colonne des intensités doit s'appeler `weight` ; il n'y a pas de contrainte particulière concernant les noms de colonnes correspondant aux sommets. Si le réseau est non orienté, on utilise la fonction `Graph()` et non `Digraph()`.\n\n```{python}\nG = nx.from_pandas_edgelist(liens,                     # data.frame des liens\n                            source = \"Origine\",        # nom de la colonne origine\n                            target = \"Arrivee\",        # nom de la colonne destination\n                            edge_attr=\"weight\",        # attribut poids pour un réseau valué\n                            create_using=nx.DiGraph()) # création d'un réseau orienté\n\n```\n\nLa gestion des attributs des sommets est un tout petit peu plus complexe et la documentation du module n'aide pas vraiment. La solution la plus simple, trouvée en ligne [à cette adresse](https://www.roelpeters.be/python-networkx-set-node-attributes-from-pandas-dataframe/), est d'utiliser la fonction `set_index` du module `pandas`. On crée un objet correspondant aux attributs des sommets, on indique quel est l'identifiant (ici `CODGEO`) et on lui demande de transformer le tableau de données en dictionnaire.\n\n```{python}\nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n\n#contrôle\nG.nodes(\"MARS\")\n```\n\nPlusieurs moyens permettent de contrôler que l'importation s'est bien déroulée :\n\n-   afficher l'ordre (nombre de sommets) ;\n-   afficher la taille (nombre de liens) ;\n-   contrôler les caractéristiques du réseau ;\n-   visualiser le réseau obtenu.\n\n```{python}\nprint(\"Ordre\", nx.number_of_nodes(G), \" sommets\")\nprint(\"Taille\", nx.number_of_edges(G), \" liens\")\nprint(\"Réseau orienté ?\", nx.is_directed(G))\n\n# attribut des liens\nprint(\"attribut des liens : \", list(list(G.edges(data=True))[0][-1].keys()))\n\n# attributs des sommets\nprint(\"attribut des sommets : \", list(list(G.nodes(data=True))[0][-1].keys()))\n\n# visualisation basique\nnx.draw_networkx(G, with_labels=False)\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"C1_importer.html"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"C1_importer.pdf"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{}}}}}