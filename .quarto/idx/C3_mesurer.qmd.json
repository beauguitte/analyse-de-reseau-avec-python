{"title":"Mesures","markdown":{"headingText":"Mesures","containsRefs":false,"markdown":"\nLes mesures sont testées sur deux réseaux, l'un orienté (`GD`) et l'autre non (`GU`), correspondant à la plus grande composante connexe. Lorsque la valuation et l'orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n'est pas abordé.\n\n```{python}\n#| echo: false\nimport pandas as pd                # manipulation de tableaux\nimport networkx as nx              # analyse de réseau\nimport numpy as np                 # statistiques\nimport matplotlib.pyplot as plt    # visualisation\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\nG = nx.from_pandas_edgelist(liens,source = \"Origine\",target = \"Arrivee\", edge_attr=\"weight\",create_using=nx.DiGraph()) \nCC = sorted(nx.weakly_connected_components(G),key=len,reverse=True) \nGD = G.subgraph(CC[0])\nGU = nx.create_empty_copy(G, with_data=True)\nGU = nx.to_undirected(GU)\nlist(list(GU.nodes(data=True))[0][-1].keys())\nGU = nx.Graph(GU)\nGU.add_edges_from(G.edges(), weight=0)\nfor u, v, d in G.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\nGcc = sorted(nx.connected_components(GU), key=len, reverse=True)\nGU = GU.subgraph(Gcc[0])\n\n```\n\n## Mesures globales\n\nDans les pages précédentes, on a déjà vu comment afficher l'ordre et la taille du réseau. La densité s'obtient avec la fonction `density`, le diamètre avec la fonction `diameter`. Lorsque les liens sont porteurs d'une intensité, il est possible de calculer une version pondérée du diamètre (intensité minimale entre les sommets les plus éloignés). Cela a un sens si la valuation peut être interprétée comme une distance (ce qui n'est pas le cas ici).\n\n```{python}\n# ordre et taille\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GD), \" sommets\")\nprint(\"nombre de liens - orienté (taille) : \", nx.number_of_edges(GD), \" liens\")\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GU), \" sommets\")\nprint(\"nombre de liens - non orienté (taille) : \", nx.number_of_edges(GU), \" liens\")\n\n# densité et diamètre\nprint(\"densité (orienté) : \", round(nx.density(GD), 2))\nprint(\"densité (non orienté) :\", round(nx.density(GU), 2))\nprint(\"Diamètre (non orienté et connexe) : \", nx.diameter(GU))\nprint(\"Diamètre (non orienté, valué) : \", nx.diameter(GU, weight = \"weight\"))\n```\n\nL'indice de Wiener, issu de l'étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets. Le réseau orienté n'étant pas fortement connexe, le résultat est une distance infinie (`inf`). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.\n\n```{python}\n# indice de wiener (somme des pcc)\nprint(\"Indice de Wiener (orienté) : \", nx.wiener_index(GD))     # distance topologique\nprint(\"Indice de Wiener (non orienté) : \", nx.wiener_index(GU)) # distance topologique\nprint(\"Indice de Wiener (non orienté, valué) : \", nx.wiener_index(GU, 'weight'))  # somme des intensités\n\n```\n\nMesures dirextement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance la plus grande entre deux sommets quelconques d'un graphe (excentricité minimale - cf *infra* les mesures locales) et à l'ensemble de sommets minimisant la fonction $\\sum_{u \\in V(G)} d_G(u, v)$, $d_G(u, v)$ étant la distance (topologique ou valuée) entre deux sommets $u$ et $v$ de $G$.\n\n```{python}\nprint(\"rayon : \", nx.radius(GU))\n\n# barycentre\nprint(\"barycentre : \", nx.barycenter(GU))\nprint(\"barycentre (valué) : \", nx.barycenter(GU, weight='weight'))\n```\n\nLa liste du ou des sommets centraux s'obtient avec `center`, la liste des sommets périphériques avec `periphery`. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.\n\n```{python}\nprint(\"Sommets centraux : \", nx.center(GU))\nprint(\"Sommets périphériques : \", nx.periphery(GU))\n```\n\nIl est possible de connaître l'ensemble des isthmes et des points d'articulation présents dans un réseau.\n\n```{python}\n# isthmes et points d'articulation (réseau connexe)\n# nombre d'isthmes\nprint(\"nb isthmes : \", len(list(nx.bridges(GU))))\n\n# liste des isthmes\nprint(\"isthmes : \",list(nx.bridges(GU)))\n\n# nombre de points d'articulation\nprint(\"nb points d'articulation : \", len(list(nx.articulation_points(GU))))\n\n# liste des points d'articulation\nprint(\"points d'articulation : \", list(nx.articulation_points(GU)))\n```\n\nMesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l'assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau dissassortatif) et 1 (réseau assortatif). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.\n\n```{python}\n# assortativité (degré par défaut)\n# orienté\nprint(\"assortativité in-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='in'),3))\n\nprint(\"assortativité in-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='out'),3))\n\nprint(\"assortativité out-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='in'),3))\n\nprint(\"assortativité out-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='out'),3))\n\n# non orienté\nprint(\"assortativité globale (non orienté) : \", \n      round(nx.degree_assortativity_coefficient(GU),3))\n\n# selon un critère autre que le degré (erreur...)\n#print(round(nx.numeric_assortativity_coefficient(GD, \"MARS\"),3))\n```\n\n\n## Mesures locales\n\nDegré : `degree` et `degree_centrality`, `ou_degree` et `in_degree`.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"C3_mesurer.html"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"C3_mesurer.pdf"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{}}}}}