{"title":"Mesurer","markdown":{"headingText":"Mesurer","containsRefs":false,"markdown":"\nLes mesures sont testées sur deux réseaux, l'un orienté (`GD`) et l'autre non (`GU`), correspondant à la plus grande composante connexe. Lorsque la valuation et l'orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n'est pas abordé.\n\n`NetworkX` propose de nombreuses mesures et méthodes issues de la théorie des graphes au sens strict (centre, barycentre, rayon, etc.) et de l'analyse des flots dans les réseaux (optimisation) ; toutes ne sont pas évoquées ici et je me suis intéressé en priorité aux méthodes me semblant - peut-être à tort - les plus utilisées en sciences sociales.\n\n```{python}\n#| echo: false\nimport pandas as pd                # manipulation de tableaux\nimport networkx as nx              # analyse de réseau\nimport numpy as np                 # statistiques\nimport matplotlib.pyplot as plt    # visualisation\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\nG = nx.from_pandas_edgelist(liens,source = \"Origine\",target = \"Arrivee\", edge_attr=\"weight\",create_using=nx.DiGraph()) \nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\nCC = sorted(nx.weakly_connected_components(G),key=len,reverse=True) \nGD = G.subgraph(CC[0])\nGU = nx.create_empty_copy(GD, with_data=True)\nGU = nx.to_undirected(GU)\nlist(list(GU.nodes(data=True))[0][-1].keys())\nGU = nx.Graph(GU)\nGU.add_edges_from(GD.edges(), weight=0)\nfor u, v, d in GD.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n```\n\n## Mesures globales\n\nDans les pages précédentes, on a déjà vu comment afficher l'ordre et la taille du réseau. La densité s'obtient avec la fonction `density`, le diamètre avec la fonction `diameter`.\n\n```{python}\n# ordre et taille\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GD), \" sommets\")\nprint(\"nombre de liens - orienté (taille) : \", nx.number_of_edges(GD), \" liens\")\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GU), \" sommets\")\nprint(\"nombre de liens - non orienté (taille) : \", nx.number_of_edges(GU), \" liens\")\n\n# densité et diamètre\nprint(\"densité (orienté) : \", round(nx.density(GD), 2))\nprint(\"densité (non orienté) :\", round(nx.density(GU), 2))\n# print(\"diamètre (non orienté et connexe) : \", nx.diameter(GD))\n```\n\nSi on cherche à mesurer le diamètre sur un réseau orienté non fortement connexe, on obtient le message d'erreur suivant : \"Found infinite path length because the digraph is not strongly connected\".\n\nMesures directement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance entre le(s) sommet(s) ayant une excentricité minimale et tout autre sommet du graphe (cf *infra* les mesures locales) et à l'ensemble de sommets minimisant la fonction $\\sum_{u \\in V(G)} d_G(u, v)$, $d_G(u, v)$ étant la distance (topologique ou valuée) entre deux sommets $u$ et $v$ de $G$.\n\n```{python}\n# rayon\nprint(\"rayon : \", nx.radius(GU))\n\n# barycentre\nprint(\"barycentre : \", nx.barycenter(GU))\nprint(\"barycentre (valué) : \", nx.barycenter(GU, weight='weight'))\n```\n\nLa liste du ou des sommets centraux s'obtient avec `center`, la liste des sommets périphériques avec `periphery`. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.\n\n```{python}\nprint(\"Sommets centraux : \", nx.center(GU))\nprint(\"Sommets périphériques : \", nx.periphery(GU))\n```\n\nComme toutes les mesures fondées sur la recherche de plus courts chemins (diamètre, rayon, etc.), ces fonctions supposent soit un réseau non orienté, soit un réseau orienté fortement connexe.\n\nIl est possible de connaître l'ensemble des isthmes et des points d'articulation présents dans un réseau.\n\n```{python}\n# isthmes et points d'articulation (réseau connexe)\n# nombre et liste des isthmes\nprint(\"nb isthmes : \", len(list(nx.bridges(GU))))\nprint(\"isthmes : \",list(nx.bridges(GU)))\n\n# nombre et liste des points d'articulation\nprint(\"nb points d'articulation : \", len(list(nx.articulation_points(GU))))\nprint(\"points d'articulation : \", list(nx.articulation_points(GU)))\n```\n\nL'indice de Wiener, issu de l'étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets (équivaut à l'indice de dispersion de Shimbel parfois utilisé par les géographes des transports). Le réseau orienté n'étant pas fortement connexe, le résultat est une distance infinie (`inf`). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.\n\n```{python}\n# indice de wiener (somme des pcc)\nprint(\"Indice de Wiener (orienté) : \", nx.wiener_index(GD))     # distance topologique\nprint(\"Indice de Wiener (non orienté) : \", nx.wiener_index(GU)) # distance topologique\nprint(\"Indice de Wiener (non orienté, valué) : \", nx.wiener_index(GU, 'weight'))  # somme des intensités\n```\n\nMesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l'assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau disassortatif, les sommets ayant un degré faible tendent à être voisins des sommets ayant un degré élevé et inversement) et 1 (réseau assortatif, les sommets ayant un degré faible sont voisins de sommets ayant un degré faible, les sommets ayant un degré élevé sont voisins de sommets ayant un degré élevé). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.\n\n```{python}\n# assortativité (degré par défaut)\n# réseau orienté - 4 options possibles\nprint(\"assortativité in-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='in'),3))\n\nprint(\"assortativité in-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='out'),3))\n\nprint(\"assortativité out-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='in'),3))\n\nprint(\"assortativité out-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='out'),3))\n\n# réseau non orienté\nprint(\"assortativité globale (non orienté) : \", \n      round(nx.degree_assortativity_coefficient(GU),3))\n\n# assortativité selon un critère autre que le degré\nprint(\"assortativité (Marseille vs autres communes) : \", \n      round(nx.numeric_assortativity_coefficient(GD, \"MARS\"),3))\n```\n\nMesure relativement proche (voir la page [wikipedia](https://en.wikipedia.org/wiki/Rich-club_coefficient)), le **rich club coefficient** s'obtient avec la fonction... `rich_club_coefficient` ; elle peut être utilisée uniquement sur des réseaux non orientés et ne tient pas compte des éventuelles boucles, liens multiples ou intensité des liens. La fonction renvoie une valeur par degré (rich club coefficient des sommets de degré 1, de degré 2, etc.).\n\n```{python}\n# rich-club coefficient\nprint(\"rich-club coefficient : \", nx.rich_club_coefficient(GU, normalized=True, seed=42))\n```\n\nLes mesures \"globales\" fondées sur des mesures \"locales\" (degré ou transitivité moyenne par exemple) sont abordées dans la section suivante.\n\n## Mesures locales\n\nLe degré se calcule à l'aide de la fonction `degree`. Si le réseau étudié est orienté, on peut utiliser `in_degree` et `out_degree`. L'argument optionnel `weight` permet de calculer le degré pondéré par l'intensité des liens.\n\n```{python}\n# degré\nprint(GD.degree())\n\n#degré entrant, sortant\nprint(GD.in_degree())\nprint(GD.out_degree())\n\n# degré entrant pondéré\nprint(GD.in_degree(weight = \"weight\"))\n```\n\nAjouter `_centrality` à la fonction utilisée permet d'obtenir les valeurs normalisées.\n\n```{python}\n# degré normalisé\nprint(nx.degree_centrality(GD))\n```\n\nPour transformer une mesure en attribut, on commence par créer un objet correspondondant au résultat puis on utilise la fonction `set_node_attributes` si la mesure porte sur les sommets et `set_edge_attributes` si elle porte sur les liens.\n\n```{python}\n# transformer une mesure en attribut \ndeg = nx.degree(GU)\nnx.set_node_attributes(GU, 'degree', deg)\nprint(\"attribut des sommets : \", list(list(GU.nodes(data=True))[0][-1].keys()))\n```\n\nLes lignes ci-dessous proposent différentes solutions pour visualiser la distribution des degrés :\n\n-   histogramme ;\n-   courbe ;\n-   courbe avec une échelle log-log.\n\n<!-- https://networkx.org/documentation/stable/auto_examples/drawing/plot_degree.html -->\n\n```{python}\n# distribution sous forme d'histogramme\ndegree_in = sorted((d for n, d in GD.in_degree()), reverse=True)\nplt.bar(*np.unique(degree_in, return_counts=True))\nplt.title(\"Degrés entrants\")\nplt.xlabel(\"Degré\")\nplt.ylabel(\"Fréquence\")\n```\n\n```{python}\n# courbe\ndegree_sequence = sorted((d for n, d in GU.degree()), reverse=True)\n\n# distribution des degrés\nplt.plot(degree_sequence, \"r-\", marker=\"o\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n```\n\n```{python}\n# distribution degré - échelle log - log\nplt.loglog(degree_sequence, \"go-\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés (log - log)\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n```\n\nIl est possible de calculer le degré moyen des voisins à à l'aide de la fonction `average_neighbor_degree` (degré entrant, sortant, total, pondéré ou non).\n\n```{python}\n#| eval: false\n# degré moyen des sommets voisins\nnx.average_neighbor_degree(GD)\n# degré entrant moyen des voisins entrants\nnx.average_neighbor_degree(GD, source=\"in\", target=\"in\")\n# degré moyen pondéré des voisins\nnx.average_neighbor_degree(GD, weight=\"weight\")\n```\n\nLes mesures de centralité autres s'obtiennent avec des fonctions aux noms attendus : `closeness`, `betweenness` (`edge_betweenness` pour l'intermédiarité des liens), `eigenvector_centrality` et `katz_centrality`.\n\n```{python}\n#| eval: false\n# intermédiarité\nnx.betweenness_centrality(GD)\nL`` \n# intermédiarité des liens\nnx.edge_betweenness_centrality(GD)\n\n# proximité\nnx.closeness_centrality(GD)\n\n# centralité de vecteur propre\nnx.eigenvector_centrality(GD)\n\n# centralité de Katz\nnx.katz_centrality(GD)\n```\n\n<!-- distance entre deux sommets : resistance_distance(G, nodeA, nodeB, weight=None, invert_weight=True)  si weight, distance; sinon, plus court chemin -->\n\nConcernant la recherche de la transitivité, on peut connaître le nom de triangles (triades fermées) contenant chaque sommet avec la fonction `triangles`. La transitivité locale s'obtient avec `clustering`, la transitivité globale avec `transitivity` et la transitivité moyenne avec `average_clustering`. Il est possible de prendre en compte l'orientation des liens et/ou leur intensité.\n\n```{python}\n#| eval: false\n# nombre de triangles\nnx.triangles(GU)\n\n# typologie MAN (réseau orienté)\nnx.triadic_census(GD) \n\n# transitivité locale\nnx.clustering(GD)\n\n# prise en compte de l'intensité des liens\nnx.clustering(GD, weight=\"weight\")\n```\n\n```{python}\n# transitivité globale et moyenne\nprint(\"Transitivité globale (orienté) : \", round(nx.transitivity(GD), 2))\nprint(\"Transitivité moyenne (orienté) : \", round(nx.average_clustering(GD), 2))\nprint(\"Transitivité globale (non orienté) : \", round(nx.transitivity(GU), 2))\nprint(\"Transitivité moyenne (non orienté) : \", round(nx.average_clustering(GU), 2))\n```\n\n<!-- v2 https://networkx.org/documentation/stable/reference/algorithms/centrality.html#second-order-centrality -->\n<!-- contrainte de Burt : nx.constraint -->\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"C3_mesurer.html"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"C3_mesurer.pdf"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{}}}}}