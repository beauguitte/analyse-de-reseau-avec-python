{"title":"Filtrer, sélectionner","markdown":{"headingText":"Filtrer, sélectionner","containsRefs":false,"markdown":"\n```{python}\n#| echo: false\nimport pandas as pd                # manipulation de tableaux\nimport networkx as nx              # analyse de réseau\nimport numpy as np                 # statistiques\nimport matplotlib.pyplot as plt    # visualisation\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\nG = nx.from_pandas_edgelist(liens,source = \"Origine\",target = \"Arrivee\", edge_attr=\"weight\",create_using=nx.DiGraph()) \nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n```\n\n## Extraire les composantes connexes\n\nLa visualisation montre un réseau non connexe. Le morceau de code qui suit décrit les différentes composantes du réseau et extrait la principale composante connexe. Le réseau étant orienté, on cherche une connexité faible (`weakly_connected_components`) ; si le réseau était non orienté, on utiliserait la fonction `connected_components`.\n\nLa logique est souvent similaire : on crée une liste correspondant au résultat ordonné d'une mesure puis on sélectionne des éléments de cette liste. Le numéro 0 entre crochets correspond au premier élément (Python numérote les éléments de 0 à **n - 1** et non de 1 à **n**).\n\n```{python}\n# liste ordonnée des composantes connexes\nCC = sorted(nx.weakly_connected_components(G),\n            key=len,                            # clé de tri - len = longueur\n            reverse=True)                       # ordre décroissant\nprint(\"Nombre de composantes\", len(CC))\n\n# nombre de sommets par composantes\nprint(\"Nombre de sommets par composantes\",\n      [len(c) for c in sorted(nx.weakly_connected_components(G),\n       key=len,\n       reverse=True)])\n\n# sélection de la composante connexe principale\nGD = G.subgraph(CC[0])\n```\n\nUne version non orientée est créée car certaines mesures imposent un réseau de ce type. La valuation des liens est conservée dans la version non orientée : par défaut, elle ne correspond pas à la somme des intensités entrantes et sortantes. Ici, l'intensité du lien *ij* dans la version non orientée correspond à l'intensité du lien *ij* dans la version orientée.\n\n<!-- v2 : gestion des intensités négatives - nx.is_negatively_weighted(G) -->\n\n```{python}\n# création d'une version non orientée\nGU = nx.to_undirected(GD)\n\nnx.is_weighted(GU)             #True\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\n```\n\nObtenir une valuation des liens dans le réseau non orienté correspondant à la somme des intensités $ij + ji$ nécessite quelques étapes supplémentaires détaillées dans les lignes ci-dessous.\n\n```{python}\n# créer une copie sans aucun lien\nGU = nx.create_empty_copy(GD, with_data=True)\nGU = nx.to_undirected(GU)\n\n# éviter message \"Frozen graph can't be modified\"\nGU = nx.Graph(GU)\n\n# récupérer liens avec intensité nulle\nGU.add_edges_from(GD.edges(), weight=0)\n\n# pour chaque lien ij + ji\nfor u, v, d in GD.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n\n# contrôle\n\n#a attributs liens et sommets\nlist(list(GU.edges(data=True))[0][-1].keys())\nlist(list(GU.nodes(data=True))[0][-1].keys())\n\n# propriétés du réseau\nnx.is_directed(GU)\nnx.is_connected(GU)\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n```\n\n## Filtrage\n\nLes données sont importées, la plus grande composante connexe a été extraite dans deux versions, une orientée et une non orientée. On peut souhaiter faire des sélections autres, que ce soit sur les sommets ou sur les liens. Deux options sont possibles : supprimer liens ou sommets selon un critère donné (`remove_edges_from()`, `remove_nodes_from`) ; sélectionner liens ou sommets selon un critère donné (`subgraph()`). \n\nSi je souhaite travailler uniquement sur le cas marseillais :\n\n```{python}\n# filtrage des sommets (1)\n# sélection des sommets satisfaisant la condition\nMars = [n for n, v in G.nodes(data=True) if v['MARS'] == True]  \n\n# création d'un sous-graphe\nGmars = G.subgraph(Mars)\n\n# visualisation\nnx.draw_networkx(Gmars,\n                 pos = nx.kamada_kawai_layout(Gmars),\n                 with_labels=True)\n```\n\nOn obtient le même résultat avec l'opération consistant à supprimer les sommets des communes hors Marseille :\n\n```{python}\n# filtrage des sommets (2)\n# sélection des sommets hors Marseille\nnonmars = [n for n,v in G.nodes(data=True) if v['MARS'] == False] \n\n# copier le réseau de départ\nGmars2 = G\n\n# supprimer les communes hors Marseille\nGmars2.remove_nodes_from(nonmars)\n\n# visualisation\nnx.draw_networkx(Gmars2,\n                 pos = nx.kamada_kawai_layout(Gmars2),\n                 with_labels=True)\n```\n\nSi je souhaite travailler uniquement sur les flux les plus importants :\n\n```{python}\n# filtrer les liens\n# paramètres statistiques\nliens.describe()\n\n# fixer un seuil (ici la médiane)\nseuil = 212\n\n# identifier les liens sous ce seuil, récupérer les identifiants\nlong_edges = list(filter(lambda e: e[2] < seuil, (e for e in G.edges.data('weight'))))\nle_ids = list(e[:2] for e in long_edges)\n\n# créer une copie du réseau de départ\nGsup = G\n\n# supprimer les liens identifiés\nGsup.remove_edges_from(le_ids)\n\n# ordre, taille et visualisation\nprint(\"Nb de sommets : \", nx.number_of_nodes(Gsup))\nprint(\"Nb de liens : \", nx.number_of_edges(Gsup))\n\nnx.draw_networkx(Gsup,\n                 pos = nx.kamada_kawai_layout(Gsup),\n                 with_labels=True)\n```\n\nLe fait de ne conserver que les liens entraîne la suppression des sommets devenant isolés. Le nombre de liens a très logiquement été divisé par deux dans la mesure où le seuil choisi ici est la médiane.\n\nSi dans un réseau donné, j'ai des sommets isolés que je souhaite éliminer, j'utilise la fonction `remove_nodes_from`.\n\nSoit un réseau aléatoire de 20 sommets contenant des isolés.\n\n```{python}\n# générer un réseau aléatoire avec 2 isolés\nrg = nx.gnp_random_graph(20, 0.05, seed = 1)\nprint(\"Nb de sommets (isolés compris) : \", nx.number_of_nodes(rg))\n\n# liste des sommets avec un degré nul\nisoles = [node for node,degree in dict(rg.degree()).items() if degree < 1]\n\n# suppression des sommets concernés\nrg.remove_nodes_from(isoles)\nprint(\"Nb de sommets  (isolés exclus) : \", nx.number_of_nodes(rg))\n```\n\n## Agrégation\n\nIl peut être intéressant d'agréger différents sommets. La fonction `contracted_nodes` prend en argument le réseau étudié et les deux sommets à fusionner, l'option `self_loops ` permet de contrôler la création d'une boucle et l'option `copy` permet de créer un nouveau réseau sans écraser le premier.\n\nSi je veux fusionner deux arrondissements marseillais, j'utilise le script suivant. Les lignes suivantes permettent de lister les liens entrants et sortants du sommet résultat de la fusion et de vérifier la présence (ici souhaitée) de la boucle.\n\n```{python}\n\nGA = nx.contracted_nodes(G, '13215', '13216', self_loops=True, copy=True)\nGA.in_edges('13215')   # liste des liens entrants\nGA.out_edges('13215')  # liste des liens sortants\n\n```\n\n<!-- v2 : fonction snap_aggregation -->"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"C2_filtrer.html"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"C2_filtrer.pdf"},"language":{"title-block-author-single":"Auteur","title-block-published":"Mis en ligne le"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"csl":"universite-de-montreal-apa.csl","toc-title":"Sommaire","date-format":"DD MM YYYY","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{}}}}}