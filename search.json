[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyse de réseau avec Python et NetworkX",
    "section": "",
    "text": "Je n’utilise pas l’écriture épicène, j’écris le plus souvent au féminin et utilise l’accord de proximité.↩︎"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "See Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, D. E. (1984). Literate programming. Comput. J., 27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Beauguitte, L. (2023). L’analyse de réseau en sciences\nsociales. Petit guide pratique. Groupe fmr. https://hal.science/hal-04052709"
  },
  {
    "objectID": "C4_partitions.html#blockmodel",
    "href": "C4_partitions.html#blockmodel",
    "title": "4  Partitionner",
    "section": "4.2 Blockmodel",
    "text": "4.2 Blockmodel\nNetworkX ne semble pas proposer de méthodes de blockmodeling. La documentation fournit un script créant une partition des sommets créée par une CAH sur la matrice d’adjacence."
  },
  {
    "objectID": "C4_partitions.html#détection-de-communautés",
    "href": "C4_partitions.html#détection-de-communautés",
    "title": "4  Partitionner",
    "section": "4.3 Détection de communautés",
    "text": "4.3 Détection de communautés\nPlusieurs méthodes de détection de communautés sont implémentées dans le sous-module community. Seule la mesure de la modularité semble disponible pour évaluer la qualité de la partition obtenue.\n\n# détection de communautés\nlouv = nx.community.louvain_communities(GU, seed=123)\nprint(\"nb de communautés (louvain) :\", len(louv))\nlouv[1]\n\n#mesure de la modularité\nprint(\"modularité (louvain) : \", round(nx.community.modularity(GU, louv),2))\n\n# algorithme maximisant la modularité\ngreed = nx.community.greedy_modularity_communities(GD)\nprint(\"nb de communautés (greedy mod.) :\", len(greed))\nprint(\"modularité (greedy mod.) : \", round(nx.community.modularity(GD, greed),2))\n\nnb de communautés (louvain) : 7\nmodularité (louvain) :  0.5\nnb de communautés (greedy mod.) : 6\nmodularité (greedy mod.) :  0.51\n\n\nLes lignes qui suivent anticipent sur la section suivante et indiquent comment visualiser les communautés détectées. La première étape est de créer un dictionnaire attribuant à chaque sommet la communauté d’appartenance détectée avec l’algorithme utilisé.\n\n# création d'un dictionnaire vide\nlouvain_dict = {} \n\n# boucle qui remplit le dictionnaire\nfor i,c in enumerate(louv): \n    for CODGEO in c: \n        louvain_dict[CODGEO] = i\n        \n# ligne optionnelle pour ajouter cet attribut \n# nx.set_node_attributes(GD, louvain_dict, 'louvain')\n\n# choix de l'algorithme de placement des sommets\npos = nx.spring_layout(GU)\n\n# importation d'une palette de couleurs \n# nb de couleurs égal au nombre de classes + 1 (Python commence à 0)\ncmap = plt.get_cmap('Paired', max(louvain_dict.values()) + 1)\n\n# visualisation des sommets\nnx.draw_networkx_nodes(GU,   # sommets à visualiser\n                       pos,  # placement\n                       louvain_dict.keys(),  # identifiants\n                       node_size=40,         # taille \n                       cmap=cmap,            # palette de couleur\n                       node_color=list(louvain_dict.values())) # affecter une couleur différente pour chaque classe\nnx.draw_networkx_edges(GU, \n                       pos, \n                       alpha=0.5)  # transparence\n\n<matplotlib.collections.LineCollection at 0x19739473880>"
  },
  {
    "objectID": "C3_mesurer.html#mesures-locales",
    "href": "C3_mesurer.html#mesures-locales",
    "title": "3  Mesurer",
    "section": "3.2 Mesures locales",
    "text": "3.2 Mesures locales\nLe degré se calcule à l’aide de la fonction degree. Si le réseau étudié est orienté, on peut utiliser in_degree et out_degree. L’argument optionnel weight permet de calculer le degré pondéré par l’intensité des liens.\n\n# degré\nprint(GD.degree())\n\n#degré entrant, sortant\nprint(GD.in_degree())\nprint(GD.out_degree())\n\n# degré entrant pondéré\nprint(GD.in_degree(weight = \"weight\"))\n\n[('13001', 72), ('13041', 6), ('13201', 24), ('13205', 23), ('13208', 20), ('13209', 22), ('13213', 33), ('13002', 8), ('13206', 23), ('13211', 16), ('13212', 16), ('13003', 2), ('13053', 2), ('13103', 16), ('13004', 8), ('13078', 2), ('13097', 4), ('13005', 19), ('13028', 7), ('13042', 2), ('13119', 3), ('13210', 17), ('13007', 2), ('13014', 2), ('13117', 11), ('13015', 1), ('13016', 3), ('13086', 2), ('13019', 1), ('13020', 1), ('13046', 5), ('13022', 3), ('13023', 1), ('13024', 1), ('13050', 3), ('13025', 1), ('13026', 4), ('13043', 7), ('13054', 11), ('13056', 10), ('13030', 2), ('13031', 1), ('13032', 1), ('13033', 2), ('13035', 1), ('13037', 4), ('13038', 1), ('13039', 3), ('13047', 9), ('13077', 4), ('13040', 3), ('13044', 1), ('13045', 2), ('13083', 1), ('13108', 3), ('13063', 5), ('13048', 2), ('13074', 3), ('13049', 1), ('13051', 3), ('13102', 3), ('13104', 2), ('13059', 2), ('13060', 3), ('13062', 2), ('13065', 2), ('13068', 1), ('13069', 3), ('13070', 2), ('13071', 8), ('13072', 2), ('13087', 3), ('13073', 1), ('13075', 2), ('13076', 1), ('13067', 2), ('13079', 2), ('13080', 2), ('13081', 2), ('13082', 2), ('13084', 2), ('13085', 2), ('13088', 1), ('13091', 2), ('13092', 2), ('13094', 1), ('13095', 1), ('13098', 2), ('13101', 1), ('13105', 3), ('13106', 3), ('13107', 1), ('13109', 1), ('13110', 1), ('13111', 1), ('13112', 3), ('13113', 1), ('13114', 2), ('13118', 2), ('13202', 7), ('13203', 16), ('13204', 15), ('13214', 14), ('13215', 13), ('13207', 10), ('13216', 4)]\n[('13001', 66), ('13041', 5), ('13201', 16), ('13205', 14), ('13208', 12), ('13209', 14), ('13213', 17), ('13002', 1), ('13206', 15), ('13211', 6), ('13212', 6), ('13003', 0), ('13053', 1), ('13103', 14), ('13004', 5), ('13078', 1), ('13097', 3), ('13005', 8), ('13028', 5), ('13042', 2), ('13119', 1), ('13210', 9), ('13007', 0), ('13014', 0), ('13117', 7), ('13015', 0), ('13016', 0), ('13086', 1), ('13019', 0), ('13020', 0), ('13046', 3), ('13022', 2), ('13023', 0), ('13024', 0), ('13050', 1), ('13025', 0), ('13026', 0), ('13043', 5), ('13054', 7), ('13056', 6), ('13030', 0), ('13031', 0), ('13032', 0), ('13033', 0), ('13035', 0), ('13037', 2), ('13038', 0), ('13039', 0), ('13047', 4), ('13077', 3), ('13040', 1), ('13044', 0), ('13045', 0), ('13083', 1), ('13108', 2), ('13063', 2), ('13048', 0), ('13074', 2), ('13049', 0), ('13051', 0), ('13102', 1), ('13104', 1), ('13059', 0), ('13060', 0), ('13062', 0), ('13065', 0), ('13068', 0), ('13069', 1), ('13070', 0), ('13071', 4), ('13072', 0), ('13087', 2), ('13073', 0), ('13075', 1), ('13076', 0), ('13067', 2), ('13079', 0), ('13080', 1), ('13081', 0), ('13082', 1), ('13084', 0), ('13085', 0), ('13088', 0), ('13091', 0), ('13092', 0), ('13094', 0), ('13095', 0), ('13098', 0), ('13101', 0), ('13105', 1), ('13106', 1), ('13107', 0), ('13109', 0), ('13110', 0), ('13111', 0), ('13112', 1), ('13113', 0), ('13114', 0), ('13118', 0), ('13202', 2), ('13203', 5), ('13204', 6), ('13214', 3), ('13215', 4), ('13207', 4), ('13216', 1)]\n[('13001', 6), ('13041', 1), ('13201', 8), ('13205', 9), ('13208', 8), ('13209', 8), ('13213', 16), ('13002', 7), ('13206', 8), ('13211', 10), ('13212', 10), ('13003', 2), ('13053', 1), ('13103', 2), ('13004', 3), ('13078', 1), ('13097', 1), ('13005', 11), ('13028', 2), ('13042', 0), ('13119', 2), ('13210', 8), ('13007', 2), ('13014', 2), ('13117', 4), ('13015', 1), ('13016', 3), ('13086', 1), ('13019', 1), ('13020', 1), ('13046', 2), ('13022', 1), ('13023', 1), ('13024', 1), ('13050', 2), ('13025', 1), ('13026', 4), ('13043', 2), ('13054', 4), ('13056', 4), ('13030', 2), ('13031', 1), ('13032', 1), ('13033', 2), ('13035', 1), ('13037', 2), ('13038', 1), ('13039', 3), ('13047', 5), ('13077', 1), ('13040', 2), ('13044', 1), ('13045', 2), ('13083', 0), ('13108', 1), ('13063', 3), ('13048', 2), ('13074', 1), ('13049', 1), ('13051', 3), ('13102', 2), ('13104', 1), ('13059', 2), ('13060', 3), ('13062', 2), ('13065', 2), ('13068', 1), ('13069', 2), ('13070', 2), ('13071', 4), ('13072', 2), ('13087', 1), ('13073', 1), ('13075', 1), ('13076', 1), ('13067', 0), ('13079', 2), ('13080', 1), ('13081', 2), ('13082', 1), ('13084', 2), ('13085', 2), ('13088', 1), ('13091', 2), ('13092', 2), ('13094', 1), ('13095', 1), ('13098', 2), ('13101', 1), ('13105', 2), ('13106', 2), ('13107', 1), ('13109', 1), ('13110', 1), ('13111', 1), ('13112', 2), ('13113', 1), ('13114', 2), ('13118', 2), ('13202', 5), ('13203', 11), ('13204', 9), ('13214', 11), ('13215', 9), ('13207', 6), ('13216', 3)]\n[('13001', 21875), ('13041', 926), ('13201', 4624), ('13205', 4649), ('13208', 2668), ('13209', 3208), ('13213', 4703), ('13002', 233), ('13206', 4730), ('13211', 1247), ('13212', 1924), ('13003', 0), ('13053', 108), ('13103', 3972), ('13004', 1127), ('13078', 173), ('13097', 367), ('13005', 1646), ('13028', 983), ('13042', 346), ('13119', 115), ('13210', 1999), ('13007', 0), ('13014', 0), ('13117', 2037), ('13015', 0), ('13016', 0), ('13086', 292), ('13019', 0), ('13020', 0), ('13046', 439), ('13022', 328), ('13023', 0), ('13024', 0), ('13050', 120), ('13025', 0), ('13026', 0), ('13043', 956), ('13054', 1433), ('13056', 1665), ('13030', 0), ('13031', 0), ('13032', 0), ('13033', 0), ('13035', 0), ('13037', 275), ('13038', 0), ('13039', 0), ('13047', 1112), ('13077', 548), ('13040', 210), ('13044', 0), ('13045', 0), ('13083', 118), ('13108', 243), ('13063', 417), ('13048', 0), ('13074', 254), ('13049', 0), ('13051', 0), ('13102', 316), ('13104', 206), ('13059', 0), ('13060', 0), ('13062', 0), ('13065', 0), ('13068', 0), ('13069', 128), ('13070', 0), ('13071', 608), ('13072', 0), ('13087', 267), ('13073', 0), ('13075', 231), ('13076', 0), ('13067', 463), ('13079', 0), ('13080', 251), ('13081', 0), ('13082', 193), ('13084', 0), ('13085', 0), ('13088', 0), ('13091', 0), ('13092', 0), ('13094', 0), ('13095', 0), ('13098', 0), ('13101', 0), ('13105', 314), ('13106', 156), ('13107', 0), ('13109', 0), ('13110', 0), ('13111', 0), ('13112', 189), ('13113', 0), ('13114', 0), ('13118', 0), ('13202', 418), ('13203', 745), ('13204', 1731), ('13214', 618), ('13215', 964), ('13207', 549), ('13216', 128)]\n\n\nAjouter _centrality à la fonction utilisée permet d’obtenir les valeurs normalisées.\n\n# degré normalisé\nprint(nx.degree_centrality(GD))\n\n{'13001': 0.6857142857142857, '13041': 0.05714285714285715, '13201': 0.2285714285714286, '13205': 0.21904761904761907, '13208': 0.1904761904761905, '13209': 0.20952380952380956, '13213': 0.31428571428571433, '13002': 0.0761904761904762, '13206': 0.21904761904761907, '13211': 0.1523809523809524, '13212': 0.1523809523809524, '13003': 0.01904761904761905, '13053': 0.01904761904761905, '13103': 0.1523809523809524, '13004': 0.0761904761904762, '13078': 0.01904761904761905, '13097': 0.0380952380952381, '13005': 0.18095238095238098, '13028': 0.06666666666666668, '13042': 0.01904761904761905, '13119': 0.028571428571428574, '13210': 0.1619047619047619, '13007': 0.01904761904761905, '13014': 0.01904761904761905, '13117': 0.10476190476190478, '13015': 0.009523809523809525, '13016': 0.028571428571428574, '13086': 0.01904761904761905, '13019': 0.009523809523809525, '13020': 0.009523809523809525, '13046': 0.04761904761904762, '13022': 0.028571428571428574, '13023': 0.009523809523809525, '13024': 0.009523809523809525, '13050': 0.028571428571428574, '13025': 0.009523809523809525, '13026': 0.0380952380952381, '13043': 0.06666666666666668, '13054': 0.10476190476190478, '13056': 0.09523809523809525, '13030': 0.01904761904761905, '13031': 0.009523809523809525, '13032': 0.009523809523809525, '13033': 0.01904761904761905, '13035': 0.009523809523809525, '13037': 0.0380952380952381, '13038': 0.009523809523809525, '13039': 0.028571428571428574, '13047': 0.08571428571428572, '13077': 0.0380952380952381, '13040': 0.028571428571428574, '13044': 0.009523809523809525, '13045': 0.01904761904761905, '13083': 0.009523809523809525, '13108': 0.028571428571428574, '13063': 0.04761904761904762, '13048': 0.01904761904761905, '13074': 0.028571428571428574, '13049': 0.009523809523809525, '13051': 0.028571428571428574, '13102': 0.028571428571428574, '13104': 0.01904761904761905, '13059': 0.01904761904761905, '13060': 0.028571428571428574, '13062': 0.01904761904761905, '13065': 0.01904761904761905, '13068': 0.009523809523809525, '13069': 0.028571428571428574, '13070': 0.01904761904761905, '13071': 0.0761904761904762, '13072': 0.01904761904761905, '13087': 0.028571428571428574, '13073': 0.009523809523809525, '13075': 0.01904761904761905, '13076': 0.009523809523809525, '13067': 0.01904761904761905, '13079': 0.01904761904761905, '13080': 0.01904761904761905, '13081': 0.01904761904761905, '13082': 0.01904761904761905, '13084': 0.01904761904761905, '13085': 0.01904761904761905, '13088': 0.009523809523809525, '13091': 0.01904761904761905, '13092': 0.01904761904761905, '13094': 0.009523809523809525, '13095': 0.009523809523809525, '13098': 0.01904761904761905, '13101': 0.009523809523809525, '13105': 0.028571428571428574, '13106': 0.028571428571428574, '13107': 0.009523809523809525, '13109': 0.009523809523809525, '13110': 0.009523809523809525, '13111': 0.009523809523809525, '13112': 0.028571428571428574, '13113': 0.009523809523809525, '13114': 0.01904761904761905, '13118': 0.01904761904761905, '13202': 0.06666666666666668, '13203': 0.1523809523809524, '13204': 0.14285714285714288, '13214': 0.13333333333333336, '13215': 0.12380952380952381, '13207': 0.09523809523809525, '13216': 0.0380952380952381}\n\n\nPour transformer une mesure en attribut, on commence par créer un objet correspondondant au résultat puis on utilise la fonction set_node_attributes si la mesure porte sur les sommets et set_edge_attributes si elle porte sur les liens.\n\n# transformer une mesure en attribut \ndeg = nx.degree(GU)\nnx.set_node_attributes(GU, 'degree', deg)\nprint(\"attribut des sommets : \", list(list(GU.nodes(data=True))[0][-1].keys()))\n\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS', DegreeView({'13001': 66, '13041': 5, '13201': 16, '13205': 14, '13208': 13, '13209': 14, '13213': 18, '13002': 7, '13206': 16, '13211': 12, '13212': 13, '13003': 2, '13053': 2, '13103': 15, '13004': 6, '13078': 1, '13097': 3, '13005': 17, '13028': 6, '13042': 2, '13119': 3, '13210': 11, '13007': 2, '13014': 2, '13117': 9, '13015': 1, '13016': 3, '13086': 2, '13019': 1, '13020': 1, '13046': 5, '13022': 3, '13023': 1, '13024': 1, '13050': 3, '13025': 1, '13026': 4, '13043': 6, '13054': 8, '13056': 7, '13030': 2, '13031': 1, '13032': 1, '13033': 2, '13035': 1, '13037': 4, '13038': 1, '13039': 3, '13047': 7, '13077': 3, '13040': 3, '13044': 1, '13045': 2, '13083': 1, '13108': 3, '13063': 4, '13048': 2, '13074': 3, '13049': 1, '13051': 3, '13102': 2, '13104': 1, '13059': 2, '13060': 3, '13062': 2, '13065': 2, '13068': 1, '13069': 2, '13070': 2, '13071': 7, '13072': 2, '13087': 3, '13073': 1, '13075': 1, '13076': 1, '13067': 2, '13079': 2, '13080': 2, '13081': 2, '13082': 2, '13084': 2, '13085': 2, '13088': 1, '13091': 2, '13092': 2, '13094': 1, '13095': 1, '13098': 2, '13101': 1, '13105': 3, '13106': 3, '13107': 1, '13109': 1, '13110': 1, '13111': 1, '13112': 3, '13113': 1, '13114': 2, '13118': 2, '13202': 5, '13203': 11, '13204': 10, '13214': 11, '13215': 10, '13207': 6, '13216': 3})]\n\n\nLes lignes ci-dessous proposent différentes solutions pour visualiser la distribution des degrés :\n\nhistogramme ;\ncourbe ;\ncourbe avec une échelle log-log.\n\n\n\n\n# distribution sous forme d'histogramme\ndegree_in = sorted((d for n, d in GD.in_degree()), reverse=True)\nplt.bar(*np.unique(degree_in, return_counts=True))\nplt.title(\"Degrés entrants\")\nplt.xlabel(\"Degré\")\nplt.ylabel(\"Fréquence\")\n\nText(0, 0.5, 'Fréquence')\n\n\n\n\n\n\n# courbe\ndegree_sequence = sorted((d for n, d in GU.degree()), reverse=True)\n\n# distribution des degrés\nplt.plot(degree_sequence, \"r-\", marker=\"o\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n\nText(0, 0.5, 'Fréquence')\n\n\n\n\n\n\n# distribution degré - échelle log - log\nplt.loglog(degree_sequence, \"go-\", linewidth=1, markersize=2)\nplt.title(\"Distribution des degrés (log - log)\")\nplt.xlabel('Degré')\nplt.ylabel('Fréquence')\n\nText(0, 0.5, 'Fréquence')\n\n\n\n\n\nIl est possible de calculer le degré moyen des voisins à à l’aide de la fonction average_neighbor_degree (degré entrant, sortant, total, pondéré ou non).\n\n# degré moyen des sommets voisins\nnx.average_neighbor_degree(GD)\n# degré entrant moyen des voisins entrants\nnx.average_neighbor_degree(GD, source=\"in\", target=\"in\")\n# degré moyen pondéré des voisins\nnx.average_neighbor_degree(GD, weight=\"weight\")\n\nLes mesures de centralité autres s’obtiennent avec des fonctions aux noms attendus : closeness, betweenness (edge_betweenness pour l’intermédiarité des liens), eigenvector_centrality et katz_centrality.\n\n# intermédiarité\nnx.betweenness_centrality(GD)\nL`` \n# intermédiarité des liens\nnx.edge_betweenness_centrality(GD)\n\n# proximité\nnx.closeness_centrality(GD)\n\n# centralité de vecteur propre\nnx.eigenvector_centrality(GD)\n\n# centralité de Katz\nnx.katz_centrality(GD)\n\n\nConcernant la recherche de la transitivité, on peut connaître le nom de triangles (triades fermées) contenant chaque sommet avec la fonction triangles. La transitivité locale s’obtient avec clustering, la transitivité globale avec transitivity et la transitivité moyenne avec average_clustering. Il est possible de prendre en compte l’orientation des liens et/ou leur intensité.\n\n# nombre de triangles\nnx.triangles(GU)\n\n# typologie MAN (réseau orienté)\nnx.triadic_census(GD) \n\n# transitivité locale\nnx.clustering(GD)\n\n# prise en compte de l'intensité des liens\nnx.clustering(GD, weight=\"weight\")\n\n\n# transitivité globale et moyenne\nprint(\"Transitivité globale (orienté) : \", round(nx.transitivity(GD), 2))\nprint(\"Transitivité moyenne (orienté) : \", round(nx.average_clustering(GD), 2))\nprint(\"Transitivité globale (non orienté) : \", round(nx.transitivity(GU), 2))\nprint(\"Transitivité moyenne (non orienté) : \", round(nx.average_clustering(GU), 2))\n\nTransitivité globale (orienté) :  0.62\nTransitivité moyenne (orienté) :  0.35\nTransitivité globale (non orienté) :  0.29\nTransitivité moyenne (non orienté) :  0.54"
  },
  {
    "objectID": "conclusion.html#avec-python",
    "href": "conclusion.html#avec-python",
    "title": "6  Pour aller plus loin",
    "section": "6.1 Avec Python",
    "text": "6.1 Avec Python\nC’est fou le nombre de livres payants proposant des initiations à des logiciels libres et gratuits. Les livres anglophones sont généralement disponibles sur libgen. Pour les livres francophones, vous pouvez 1. voir auprès de votre bibliothèque universitaire favorite ou 2. contactez directement l’auteur et l’autrice pour demander gentiment s’il n’y a pas une version pdf disponible quelque part.\nPour s’initier, Openclassrooms propose des cours plutôt corrects. Ce n’est pas pensé pour des utilisatrices en sciences sociales et on peut allégrement sauter certaines étapes mais ça reste utile.\nOrienté sciences sociales, le dépôt github d’Émilien Schultz propose une liste de ressources utiles pour l’utilisation de Python et les supports des nombreuses formations qu’il a dispensées ces dernières années. Orienté sciences sociales mais en anglais, le site de Melanie Walsh est très chaudement recommandé.\nL’excellent site Programming Historian propose 28 leçons sur Python, toutes disponibles en anglais, certaines sont traduites en espagnol, français et/ou portugais.\nLe site Python Graph Gallery, copié sur The R Graph Gallery, permet de récupérer le code pour générer de belles figures. Ça reste cependant moins complet - et parfois moins joli - que ce qu’on peut faire avec R."
  },
  {
    "objectID": "C1_importer.html",
    "href": "C1_importer.html",
    "title": "1  Importer ses données",
    "section": "",
    "text": "La table som_d13.csv contient les attributs suivants :\n\nCODGEO : code INSEE de la commune ;\nP19_POP : population résidente en 2019 (entiers) ;\nSUPERF : superficie (flottants) ;\nSUP_QUALI : superficie inférieure ou supérieure à la moyenne départementale (chaîne de caractères). Des données ont été volontairement supprimés pour voir comment gérer les données manquantes ;\nNOM : nom de la commune ;\nMARS : variable booléenne permettant de savoir si la commune est un arrondissement de Marseille (1) ou non (0).\n\nLa table liens_d13.csv contient les attributs suivants :\n\nOrigine : code INSEE de la commune de départ ;\nArrivee : code INSEE de la commune d’arrivée ;\nweight : flux d’élèves entre communes (flux > 100).\n\nCes deux fichiers encodés en utf-8 permettent de créer un réseau simple, orienté et valué. Les réseaux autres (bimodaux, multiplexes, avec boucles) ne sont pas évoqués dans ce document.\nPour l’importation et la manipulation des données, soit vous savez utiliser Python et vous n’avez pas besoin de lire les paragraphes qui suivent, soit vous débutez en Python et utiliser le module pandas est recommmandé.\n\nsommets = pd.read_csv(\"data/som_d13.csv\", sep = \";\")\nliens = pd.read_csv(\"data/liens_d13.csv\", sep = \";\")\n\nAvant de transformer ces tables en un réseau, il est prudent de contrôler le typage par défaut qu’a choisi pandas lors de l’importation avec la fonction dtypes. Il faut en effet que les codes INSEE soient considérés comme des chaînes de caractères (str) et non comme des entiers (int64), et que la variable MARS soit considérée comme une variable booléenne (bool).\n\nprint(sommets.dtypes)\nprint(liens.dtypes)\n\nCODGEO         int64\nP19_POP        int64\nSUPERF       float64\nSUP_QUALI     object\nNOM           object\nMARS           int64\ndtype: object\nOrigine    int64\nArrivee    int64\nweight     int64\ndtype: object\n\n\nLes lignes ci-dessous permettent de typer correctement les données.\n\n# typage des variables\nsommets[['CODGEO']] = sommets[['CODGEO']].astype('string')\nsommets[['MARS']] = sommets[['MARS']].astype('bool')\n\nliens[['Origine']] = liens[['Origine']].astype('string')\nliens[['Arrivee']] = liens[['Arrivee']].astype('string')\n\nLa syntaxe pour créer un réseau orienté à partir d’une liste de liens est relativement simple. On précise quelle est la colonne des origines, celle des destinations, s’il existe une valuation des liens et si le graphe est orienté.\nPour que le réseau soit considéré comme valué, la colonne des intensités doit s’appeler weight ; il n’y a pas de contrainte particulière concernant les noms de colonnes correspondant aux sommets. Si le réseau est non orienté, on utilise la fonction Graph() et non Digraph().\n\nG = nx.from_pandas_edgelist(liens,                     # data.frame des liens\n                            source = \"Origine\",        # nom de la colonne origine\n                            target = \"Arrivee\",        # nom de la colonne destination\n                            edge_attr=\"weight\",        # attribut poids pour un réseau valué\n                            create_using=nx.DiGraph()) # création d'un réseau orienté\n\nLa gestion des attributs des sommets est un tout petit peu plus complexe et la documentation du module n’aide pas vraiment. La solution la plus simple, trouvée en ligne à cette adresse, est d’utiliser la fonction set_index du module pandas. On crée un objet correspondant aux attributs des sommets, on indique quel est l’identifiant (ici CODGEO) et on lui demande de transformer le tableau de données en dictionnaire.\n\nnodes_attr = sommets.set_index('CODGEO').to_dict(orient = 'index')\nnx.set_node_attributes(G, nodes_attr)\n\n#contrôle\nG.nodes(\"MARS\")\n\nNodeDataView({'13001': False, '13041': False, '13201': True, '13205': True, '13208': True, '13209': True, '13213': True, '13002': False, '13206': True, '13211': True, '13212': True, '13003': False, '13053': False, '13103': False, '13004': False, '13078': False, '13097': False, '13005': False, '13028': False, '13042': False, '13119': False, '13210': True, '13007': False, '13014': False, '13117': False, '13015': False, '13016': False, '13086': False, '13018': False, '13089': False, '13019': False, '13020': False, '13046': False, '13022': False, '13023': False, '13024': False, '13050': False, '13025': False, '13026': False, '13043': False, '13054': False, '13056': False, '13030': False, '13031': False, '13032': False, '13033': False, '13035': False, '13036': False, '13100': False, '13037': False, '13038': False, '13039': False, '13047': False, '13077': False, '13040': False, '13044': False, '13045': False, '13083': False, '13108': False, '13063': False, '13048': False, '13074': False, '13049': False, '13051': False, '13052': False, '13102': False, '13104': False, '13059': False, '13060': False, '13062': False, '13064': False, '13065': False, '13066': False, '13027': False, '13068': False, '13069': False, '13070': False, '13071': False, '13072': False, '13087': False, '13073': False, '13075': False, '13076': False, '13067': False, '13079': False, '13080': False, '13081': False, '13082': False, '13084': False, '13085': False, '13088': False, '13091': False, '13092': False, '13094': False, '13095': False, '13098': False, '13101': False, '13105': False, '13106': False, '13107': False, '13109': False, '13110': False, '13111': False, '13112': False, '13113': False, '13114': False, '13118': False, '13202': True, '13203': True, '13204': True, '13214': True, '13215': True, '13207': True, '13216': True}, data='MARS')\n\n\nPlusieurs moyens permettent de contrôler que l’importation s’est bien déroulée :\n\nafficher l’ordre (nombre de sommets) ;\nafficher la taille (nombre de liens) ;\ncontrôler les caractéristiques du réseau ;\nvisualiser le réseau obtenu.\n\n\nprint(\"Ordre\", nx.number_of_nodes(G), \" sommets\")\nprint(\"Taille\", nx.number_of_edges(G), \" liens\")\nprint(\"Réseau orienté ?\", nx.is_directed(G))\n\n# attribut des liens\nprint(\"attribut des liens : \", list(list(G.edges(data=True))[0][-1].keys()))\n\n# attributs des sommets\nprint(\"attribut des sommets : \", list(list(G.nodes(data=True))[0][-1].keys()))\n\n# visualisation basique\nnx.draw_networkx(G, with_labels=False)\n\nOrdre 114  sommets\nTaille 317  liens\nRéseau orienté ? True\nattribut des liens :  ['weight']\nattribut des sommets :  ['P19_POP', 'SUPERF', 'SUP_QUALI', 'NOM', 'MARS']"
  },
  {
    "objectID": "C2_filtrer.html",
    "href": "C2_filtrer.html",
    "title": "2  Filtrer, sélectionner",
    "section": "",
    "text": "La visualisation montre un réseau non connexe. Le morceau de code qui suit décrit les différentes composantes du réseau et extrait la principale composante connexe. Le réseau étant orienté, on cherche une connexité faible (weakly_connected_components) ; si le réseau était non orienté, on utiliserait la fonction connected_components.\nLa logique est souvent similaire : on crée une liste correspondant au résultat ordonné d’une mesure puis on sélectionne des éléments de cette liste. Le numéro 0 entre crochets correspond au premier élément (Python numérote les éléments de 0 à n - 1 et non de 1 à n).\n\n# liste ordonnée des composantes connexes\nCC = sorted(nx.weakly_connected_components(G),\n            key=len,                            # clé de tri - len = longueur\n            reverse=True)                       # ordre décroissant\nprint(\"Nombre de composantes\", len(CC))\n\n# nombre de sommets par composantes\nprint(\"Nombre de sommets par composantes\",\n      [len(c) for c in sorted(nx.weakly_connected_components(G),\n       key=len,\n       reverse=True)])\n\n# sélection de la composante connexe principale\nGD = G.subgraph(CC[0])\n\nNombre de composantes 4\nNombre de sommets par composantes [106, 3, 3, 2]\n\n\nUne version non orientée est créée car certaines mesures imposent un réseau de ce type. La valuation des liens est conservée dans la version non orientée : par défaut, elle ne correspond pas à la somme des intensités entrantes et sortantes. Ici, l’intensité du lien ij dans la version non orientée correspond à l’intensité du lien ij dans la version orientée.\n\n\n# création d'une version non orientée\nGU = nx.to_undirected(GD)\n\nnx.is_weighted(GU)             #True\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  135\n\n\nObtenir une valuation des liens dans le réseau non orienté correspondant à la somme des intensités \\(ij + ji\\) nécessite quelques étapes supplémentaires détaillées dans les lignes ci-dessous.\n\n# créer une copie sans aucun lien\nGU = nx.create_empty_copy(GD, with_data=True)\nGU = nx.to_undirected(GU)\n\n# éviter message \"Frozen graph can't be modified\"\nGU = nx.Graph(GU)\n\n# récupérer liens avec intensité nulle\nGU.add_edges_from(GD.edges(), weight=0)\n\n# pour chaque lien ij + ji\nfor u, v, d in GD.edges(data=True):\n    GU[u][v]['weight'] += d['weight']\n\n# contrôle\n\n#a attributs liens et sommets\nlist(list(GU.edges(data=True))[0][-1].keys())\nlist(list(GU.nodes(data=True))[0][-1].keys())\n\n# propriétés du réseau\nnx.is_directed(GU)\nnx.is_connected(GU)\n\nprint(\"lien ij :\", GD[\"13001\"][\"13201\"]['weight'])\nprint(\"lien ji :\", GD[\"13201\"][\"13001\"]['weight'])\nprint(\"lien ij non orienté : \", GU[\"13001\"][\"13201\"]['weight'])\n\nlien ij : 135\nlien ji : 499\nlien ij non orienté :  634"
  },
  {
    "objectID": "C2_filtrer.html#filtrage",
    "href": "C2_filtrer.html#filtrage",
    "title": "2  Filtrer, sélectionner",
    "section": "2.2 Filtrage",
    "text": "2.2 Filtrage\nLes données sont importées, la plus grande composante connexe a été extraite dans deux versions, une orientée et une non orientée. On peut souhaiter faire des sélections autres, que ce soit sur les sommets ou sur les liens. Deux options sont possibles : supprimer liens ou sommets selon un critère donné (remove_edges_from(), remove_nodes_from) ; sélectionner liens ou sommets selon un critère donné (subgraph()).\nSi je souhaite travailler uniquement sur le cas marseillais :\n\n# filtrage des sommets (1)\n# sélection des sommets satisfaisant la condition\nMars = [n for n, v in G.nodes(data=True) if v['MARS'] == True]  \n\n# création d'un sous-graphe\nGmars = G.subgraph(Mars)\n\n# visualisation\nnx.draw_networkx(Gmars,\n                 pos = nx.kamada_kawai_layout(Gmars),\n                 with_labels=True)\n\n\n\n\nOn obtient le même résultat avec l’opération consistant à supprimer les sommets des communes hors Marseille :\n\n# filtrage des sommets (2)\n# sélection des sommets hors Marseille\nnonmars = [n for n,v in G.nodes(data=True) if v['MARS'] == False] \n\n# copier le réseau de départ\nGmars2 = G\n\n# supprimer les communes hors Marseille\nGmars2.remove_nodes_from(nonmars)\n\n# visualisation\nnx.draw_networkx(Gmars2,\n                 pos = nx.kamada_kawai_layout(Gmars2),\n                 with_labels=True)\n\n\n\n\nSi je souhaite travailler uniquement sur les flux les plus importants :\n\n# filtrer les liens\n# paramètres statistiques\nliens.describe()\n\n# fixer un seuil (ici la médiane)\nseuil = 212\n\n# identifier les liens sous ce seuil, récupérer les identifiants\nlong_edges = list(filter(lambda e: e[2] < seuil, (e for e in G.edges.data('weight'))))\nle_ids = list(e[:2] for e in long_edges)\n\n# créer une copie du réseau de départ\nGsup = G\n\n# supprimer les liens identifiés\nGsup.remove_edges_from(le_ids)\n\n# ordre, taille et visualisation\nprint(\"Nb de sommets : \", nx.number_of_nodes(Gsup))\nprint(\"Nb de liens : \", nx.number_of_edges(Gsup))\n\nnx.draw_networkx(Gsup,\n                 pos = nx.kamada_kawai_layout(Gsup),\n                 with_labels=True)\n\nNb de sommets :  16\nNb de liens :  64\n\n\n\n\n\nLe fait de ne conserver que les liens entraîne la suppression des sommets devenant isolés. Le nombre de liens a très logiquement été divisé par deux dans la mesure où le seuil choisi ici est la médiane.\nSi dans un réseau donné, j’ai des sommets isolés que je souhaite éliminer, j’utilise la fonction remove_nodes_from.\nSoit un réseau aléatoire de 20 sommets contenant des isolés.\n\n# générer un réseau aléatoire avec 2 isolés\nrg = nx.gnp_random_graph(20, 0.05, seed = 1)\nprint(\"Nb de sommets (isolés compris) : \", nx.number_of_nodes(rg))\n\n# liste des sommets avec un degré nul\nisoles = [node for node,degree in dict(rg.degree()).items() if degree < 1]\n\n# suppression des sommets concernés\nrg.remove_nodes_from(isoles)\nprint(\"Nb de sommets  (isolés exclus) : \", nx.number_of_nodes(rg))\n\nNb de sommets (isolés compris) :  20\nNb de sommets  (isolés exclus) :  18"
  },
  {
    "objectID": "C2_filtrer.html#agrégation",
    "href": "C2_filtrer.html#agrégation",
    "title": "2  Filtrer, sélectionner",
    "section": "2.3 Agrégation",
    "text": "2.3 Agrégation\nIl peut être intéressant d’agréger différents sommets. La fonction contracted_nodes prend en argument le réseau étudié et les deux sommets à fusionner, l’option self_loops permet de contrôler la création d’une boucle et l’option copy permet de créer un nouveau réseau sans écraser le premier.\nSi je veux fusionner deux arrondissements marseillais, j’utilise le script suivant. Les lignes suivantes permettent de lister les liens entrants et sortants du sommet résultat de la fusion et de vérifier la présence (ici souhaitée) de la boucle.\n\nGA = nx.contracted_nodes(G, '13215', '13216', self_loops=True, copy=True)\nGA.in_edges('13215')   # liste des liens entrants\nGA.out_edges('13215')  # liste des liens sortants\n\nOutEdgeDataView([('13215', '13213'), ('13215', '13214'), ('13215', '13215')])"
  },
  {
    "objectID": "C3_mesurer.html",
    "href": "C3_mesurer.html",
    "title": "3  Mesurer",
    "section": "",
    "text": "Les mesures sont testées sur deux réseaux, l’un orienté (GD) et l’autre non (GU), correspondant à la plus grande composante connexe. Lorsque la valuation et l’orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n’est pas abordé.\nNetworkX propose de nombreuses mesures et méthodes issues de la théorie des graphes au sens strict (centre, barycentre, rayon, etc.) et de l’analyse des flots dans les réseaux (optimisation) ; toutes ne sont pas évoquées ici et je me suis intéressé en priorité aux méthodes me semblant - peut-être à tort - les plus utilisées en sciences sociales."
  },
  {
    "objectID": "C3_mesurer.html#mesures-globales",
    "href": "C3_mesurer.html#mesures-globales",
    "title": "3  Mesurer",
    "section": "3.1 Mesures globales",
    "text": "3.1 Mesures globales\nDans les pages précédentes, on a déjà vu comment afficher l’ordre et la taille du réseau. La densité s’obtient avec la fonction density, le diamètre avec la fonction diameter.\n\n# ordre et taille\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GD), \" sommets\")\nprint(\"nombre de liens - orienté (taille) : \", nx.number_of_edges(GD), \" liens\")\nprint(\"nombre de sommets (ordre) : \", nx.number_of_nodes(GU), \" sommets\")\nprint(\"nombre de liens - non orienté (taille) : \", nx.number_of_edges(GU), \" liens\")\n\n# densité et diamètre\nprint(\"densité (orienté) : \", round(nx.density(GD), 2))\nprint(\"densité (non orienté) :\", round(nx.density(GU), 2))\n# print(\"diamètre (non orienté et connexe) : \", nx.diameter(GD))\n\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - orienté (taille) :  312  liens\nnombre de sommets (ordre) :  106  sommets\nnombre de liens - non orienté (taille) :  250  liens\ndensité (orienté) :  0.03\ndensité (non orienté) : 0.04\n\n\nSi on cherche à mesurer le diamètre sur un réseau orienté non fortement connexe, on obtient le message d’erreur suivant : “Found infinite path length because the digraph is not strongly connected”.\nMesures directement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance entre le(s) sommet(s) ayant une excentricité minimale et tout autre sommet du graphe (cf infra les mesures locales) et à l’ensemble de sommets minimisant la fonction \\(\\sum_{u \\in V(G)} d_G(u, v)\\), \\(d_G(u, v)\\) étant la distance (topologique ou valuée) entre deux sommets \\(u\\) et \\(v\\) de \\(G\\).\n\n# rayon\nprint(\"rayon : \", nx.radius(GU))\n\n# barycentre\nprint(\"barycentre : \", nx.barycenter(GU))\nprint(\"barycentre (valué) : \", nx.barycenter(GU, weight='weight'))\n\nrayon :  4\nbarycentre :  ['13001']\nbarycentre (valué) :  ['13001']\n\n\nLa liste du ou des sommets centraux s’obtient avec center, la liste des sommets périphériques avec periphery. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.\n\nprint(\"Sommets centraux : \", nx.center(GU))\nprint(\"Sommets périphériques : \", nx.periphery(GU))\n\nSommets centraux :  ['13001']\nSommets périphériques :  ['13083', '13076']\n\n\nComme toutes les mesures fondées sur la recherche de plus courts chemins (diamètre, rayon, etc.), ces fonctions supposent soit un réseau non orienté, soit un réseau orienté fortement connexe.\nIl est possible de connaître l’ensemble des isthmes et des points d’articulation présents dans un réseau.\n\n# isthmes et points d'articulation (réseau connexe)\n# nombre et liste des isthmes\nprint(\"nb isthmes : \", len(list(nx.bridges(GU))))\nprint(\"isthmes : \",list(nx.bridges(GU)))\n\n# nombre et liste des points d'articulation\nprint(\"nb points d'articulation : \", len(list(nx.articulation_points(GU))))\nprint(\"points d'articulation : \", list(nx.articulation_points(GU)))\n\nnb isthmes :  32\nisthmes :  [('13001', '13004'), ('13001', '13015'), ('13001', '13019'), ('13001', '13025'), ('13001', '13032'), ('13001', '13095'), ('13001', '13107'), ('13001', '13109'), ('13001', '13110'), ('13001', '13111'), ('13001', '13113'), ('13213', '13075'), ('13103', '13035'), ('13103', '13044'), ('13103', '13049'), ('13004', '13078'), ('13004', '13038'), ('13004', '13108'), ('13097', '13068'), ('13005', '13031'), ('13028', '13023'), ('13020', '13046'), ('13046', '13073'), ('13046', '13101'), ('13024', '13050'), ('13054', '13088'), ('13056', '13104'), ('13045', '13083'), ('13045', '13108'), ('13108', '13094'), ('13076', '13067'), ('13067', '13105')]\nnb points d'articulation :  15\npoints d'articulation :  ['13046', '13028', '13005', '13054', '13103', '13050', '13067', '13105', '13056', '13213', '13004', '13097', '13045', '13108', '13001']\n\n\nL’indice de Wiener, issu de l’étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets (équivaut à l’indice de dispersion de Shimbel parfois utilisé par les géographes des transports). Le réseau orienté n’étant pas fortement connexe, le résultat est une distance infinie (inf). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.\n\n# indice de wiener (somme des pcc)\nprint(\"Indice de Wiener (orienté) : \", nx.wiener_index(GD))     # distance topologique\nprint(\"Indice de Wiener (non orienté) : \", nx.wiener_index(GU)) # distance topologique\nprint(\"Indice de Wiener (non orienté, valué) : \", nx.wiener_index(GU, 'weight'))  # somme des intensités\n\nIndice de Wiener (orienté) :  inf\nIndice de Wiener (non orienté) :  15228.0\nIndice de Wiener (non orienté, valué) :  3800738.0\n\n\nMesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l’assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau disassortatif, les sommets ayant un degré faible tendent à être voisins des sommets ayant un degré élevé et inversement) et 1 (réseau assortatif, les sommets ayant un degré faible sont voisins de sommets ayant un degré faible, les sommets ayant un degré élevé sont voisins de sommets ayant un degré élevé). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.\n\n# assortativité (degré par défaut)\n# réseau orienté - 4 options possibles\nprint(\"assortativité in-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='in'),3))\n\nprint(\"assortativité in-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"in\", y='out'),3))\n\nprint(\"assortativité out-in : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='in'),3))\n\nprint(\"assortativité out-out : \", \n      round(nx.degree_assortativity_coefficient(GD, x=\"out\", y='out'),3))\n\n# réseau non orienté\nprint(\"assortativité globale (non orienté) : \", \n      round(nx.degree_assortativity_coefficient(GU),3))\n\n# assortativité selon un critère autre que le degré\nprint(\"assortativité (Marseille vs autres communes) : \", \n      round(nx.numeric_assortativity_coefficient(GD, \"MARS\"),3))\n\nassortativité in-in :  -0.105\nassortativité in-out :  0.262\nassortativité out-in :  -0.198\nassortativité out-out :  0.485\nassortativité globale (non orienté) :  -0.234\nassortativité (Marseille vs autres communes) :  0.707\n\n\nMesure relativement proche (voir la page wikipedia), le rich club coefficient s’obtient avec la fonction… rich_club_coefficient ; elle peut être utilisée uniquement sur des réseaux non orientés et ne tient pas compte des éventuelles boucles, liens multiples ou intensité des liens. La fonction renvoie une valeur par degré (rich club coefficient des sommets de degré 1, de degré 2, etc.).\n\n# rich-club coefficient\nprint(\"rich-club coefficient : \", nx.rich_club_coefficient(GU, normalized=True, seed=42))\n\nrich-club coefficient :  {0: 1.0, 1: 0.9955156950672646, 2: 1.0119047619047619, 3: 1.0546875, 4: 1.0677966101694916, 5: 1.0727272727272728, 6: 1.153846153846154, 7: 1.168831168831169, 8: 1.2222222222222223, 9: 1.303030303030303, 10: 1.320754716981132, 11: 1.25, 12: 1.2000000000000002, 13: 1.1052631578947367, 14: 1.1111111111111112, 15: 1.3333333333333335, 16: 1.5, 17: 1.0}\n\n\nLes mesures “globales” fondées sur des mesures “locales” (degré ou transitivité moyenne par exemple) sont abordées dans la section suivante."
  },
  {
    "objectID": "C4_partitions.html",
    "href": "C4_partitions.html",
    "title": "4  Partitionner",
    "section": "",
    "text": "La page de la documentation consacrée aux cliques propose x fonctions dont plusieurs sont obsolotètes. Par défaut, NetworkX renvoit tous les ous-graphes complets d’ordre 1 à n, n correspondant au sous-graphe maximal complet et donc à la clique au sens strict du terme.\n\n# cliques d'ordre 1 à n\nprint(\"Nombre de `cliques' : \", sum(1 for c in nx.find_cliques(GU)))\nprint(\"Nombre de sommets dans la plus grande clique : \", max(len(c) for c in nx.find_cliques(GU)))\nprint(\"Composition de la plus grande clique \\n\", max(nx.find_cliques(GU), key=len))\n\nNombre de `cliques' :  86\nNombre de sommets dans la plus grande clique :  10\nComposition de la plus grande clique \n ['13001', '13213', '13201', '13206', '13205', '13209', '13212', '13208', '13211', '13210']\n\n\nNombre de variations des k-cores sont proposées (k-shell, k-crust, k-corona…), elles seront abordées dans une version ultérieure de ce tutoriel.\n\n# ordre des k-cores\nprint(list(nx.k_components(GU)))\n\n# composition du 8-core\nlist(nx.k_core(GU, k = 8))\n\n[8, 7, 6, 5, 4, 3, 2, 1]\n\n\n['13205',\n '13213',\n '13214',\n '13211',\n '13201',\n '13206',\n '13001',\n '13209',\n '13203',\n '13005',\n '13212',\n '13208',\n '13204',\n '13210']"
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "6  Pour aller plus loin",
    "section": "",
    "text": "Pour aller plus loin en analyse de réseau (avec Python ou tout autre logiciel), commencer par la liste Awesome Network Analysis maintenue par François Briatte est un bon réflexe. La partie Python mériterait peut-être un coup de plumeau, notamment pour les modules conseillés - c’est inscrit sur ma to-do-list de l’été mais je ne promets rien…"
  },
  {
    "objectID": "conclusion.html#avec-networkx",
    "href": "conclusion.html#avec-networkx",
    "title": "6  Pour aller plus loin",
    "section": "6.2 Avec NetworkX",
    "text": "6.2 Avec NetworkX\nLe site officiel est touffu (euphémisme). Nombre de fonctions sont obsolètes et la documentation n’est pas toujours d’une grande clarté. On trouve quelques tutoriels sur l’analyse de réseaux avec NetworkX en ligne : j’ai notamment utilisé des morceaux de Programming Historian (Ladd et al. (2017)) et d’un cours de l’IUT de Reims (Blanchard (2018)). Beaucoup plus complet, le datacamp accessible à cette adresse est très complet mais commence à dater (2020), certaines parties ne fonctionnent plus très bien.\n\n\n\n\n\nBlanchard, F. (2018). Analyse des réseaux sociaux en python. https://iut-info.univ-reims.fr/users/blanchard/ISN20181218/index.html\n\n\nLadd, J. R., Otis, J., Warren, C. N. and Weingart, S. (2017). Exploring and analyzing network data with python. Programming Historian. https://doi.org/https://doi.org/10.46430/phen0064"
  },
  {
    "objectID": "C6_visualiser.html",
    "href": "C6_visualiser.html",
    "title": "5  Visualiser ses données",
    "section": "",
    "text": "#graphe de Petersen\n#pour les plus curieuses : https://fr.wikipedia.org/wiki/Graphe_de_Petersen\nG = nx.petersen_graph()\n\n# algorithmes de visualisation\n# juxtaposer des fenêtres\nfig, ax = plt.subplots(3, 2, figsize = (9,8))         # 3 lignes, 2 colonnes\nnx.draw_networkx(G, ax = ax[0,0])    # ax[0,0] : à placer sur la première ligne, première colonne\nax[0,0].set_title('Default (Spring)')         # titre de la figure\nnx.draw_networkx(G, pos = nx.random_layout(G), ax = ax[0,1])\nax[0,1].set_title('Random layout')\nnx.draw_networkx(G, pos = nx.shell_layout(G), ax = ax[1,0])\nax[1,0].set_title('Shell layout')\nnx.draw_networkx(G, pos = nx.spectral_layout(G), ax = ax[1,1])\nax[1,1].set_title('Spectral layout')\nnx.draw_networkx(G, pos = nx.kamada_kawai_layout(G), ax = ax[2,0])\nax[2,0].set_title('Kamada Kawai layout')\nnx.draw_networkx(G, pos = nx.spiral_layout(G), ax = ax[2,1])\nax[2,1].set_title('Spiral layout')\n\nText(0.5, 1.0, 'Spiral layout')\n\n\n\n\n\nIl est évidemment possible de modifier l’apparence des sommets et des liens et, par exemple, de faire varier la taille ou la couleur en fonction d’un attribut. Il est souvent nécessaire de créer au préalable un dictionnaire permettant de faire varier le paramètre graphique voulu selon un indicateur donné, par exemple faire varier la taille des sommets selon le degré.\nLes exemples ci-dessous ne prétendent pas à l’exhaustivité mais illustrent l’utilisation de quelques paramètres graphiques d’usage courant.\n\n# création du dictionnaire pour les degrés\nd = dict(GU.degree)\n\n# création d'une liste des intensités\nweights = [GU[u][v]['weight'] for u,v in GU.edges]\n\nnx.draw_networkx(GU,\n               pos = nx.spring_layout(GU),  # algorithme de placement\n               node_color = 'orange',  # couleur des sommets\n               alpha = 0.8,            # transparence\n               nodelist= d.keys(),     # liste des sommets      \n               node_size = [v * 20 for v in d.values()], # taille des sommets\n               edge_cmap=plt.cm.Blues, # palette de couleurs\n               edge_color = weights,   # couleur des liens\n               with_labels=False,      # affichage des labels\n               width=4)                # épaisseur des liens\n\n\n\n\n\n# faire varier teinte et épaisseur des liens\n# diviser les intensités par 100\n\nweigh2 = [i/100 for i in weights]\n\nnx.draw_networkx(GU,\n               pos = nx.kamada_kawai_layout(GU),\n               node_color = 'orange', \n               alpha = 0.8,\n               nodelist= d.keys(), \n               node_size = [v * 20 for v in d.values()], \n               edge_cmap=plt.cm.Blues,\n               edge_color = weights,\n               with_labels = False,\n               width=weigh2)\n\n\n\n\nSi on souhaite produire plusieurs figures avec la même apparence, le plus simple est de définir au préalable les options de visualisation puis de les appeler.\n\n# définir les options de visualisation\noptions = {\n      'node_color' : 'orange',\n      'node_size'  : 40, \n      'edge_color' : 'blue',\n      'width' : 1,\n      'alpha' : 0.8,\n      'with_labels': False\n    }\n\n# visualiser\nnx.draw_networkx(G, **options)\n\n\n\n\nOn trouve en ligne des exemples permettant de tester d’autres types de visualisation (matrice, edge-bundling, etc.). Ces points seront évoqués dans une version ultérieure de ce tutoriel."
  }
]