# Mesures

Les mesures sont testées sur deux réseaux, l'un orienté (`GD`) et l'autre non (`GU`), correspondant à la plus grande composante connexe. Lorsque la valuation et l'orientation des liens peuvent être prises en compte, les options utiles sont signalées. Par contre, le cas des liens multiples et des boucles n'est pas abordé.

```{python}
#| echo: false
import pandas as pd                # manipulation de tableaux
import networkx as nx              # analyse de réseau
import numpy as np                 # statistiques
import matplotlib.pyplot as plt    # visualisation
sommets = pd.read_csv("data/som_d13.csv", sep = ";")
liens = pd.read_csv("data/liens_d13.csv", sep = ";")
sommets[['CODGEO']] = sommets[['CODGEO']].astype('string')
sommets[['MARS']] = sommets[['MARS']].astype('bool')
liens[['Origine']] = liens[['Origine']].astype('string')
liens[['Arrivee']] = liens[['Arrivee']].astype('string')
G = nx.from_pandas_edgelist(liens,source = "Origine",target = "Arrivee", edge_attr="weight",create_using=nx.DiGraph()) 
CC = sorted(nx.weakly_connected_components(G),key=len,reverse=True) 
GD = G.subgraph(CC[0])
GU = nx.create_empty_copy(G, with_data=True)
GU = nx.to_undirected(GU)
list(list(GU.nodes(data=True))[0][-1].keys())
GU = nx.Graph(GU)
GU.add_edges_from(G.edges(), weight=0)
for u, v, d in G.edges(data=True):
    GU[u][v]['weight'] += d['weight']
Gcc = sorted(nx.connected_components(GU), key=len, reverse=True)
GU = GU.subgraph(Gcc[0])

```

## Mesures globales

Dans les pages précédentes, on a déjà vu comment afficher l'ordre et la taille du réseau. La densité s'obtient avec la fonction `density`, le diamètre avec la fonction `diameter`. Lorsque les liens sont porteurs d'une intensité, il est possible de calculer une version pondérée du diamètre (intensité minimale entre les sommets les plus éloignés). Cela a un sens si la valuation peut être interprétée comme une distance (ce qui n'est pas le cas ici).

```{python}
# ordre et taille
print("nombre de sommets (ordre) : ", nx.number_of_nodes(GD), " sommets")
print("nombre de liens - orienté (taille) : ", nx.number_of_edges(GD), " liens")
print("nombre de sommets (ordre) : ", nx.number_of_nodes(GU), " sommets")
print("nombre de liens - non orienté (taille) : ", nx.number_of_edges(GU), " liens")

# densité et diamètre
print("densité (orienté) : ", round(nx.density(GD), 2))
print("densité (non orienté) :", round(nx.density(GU), 2))
print("Diamètre (non orienté et connexe) : ", nx.diameter(GU))
print("Diamètre (non orienté, valué) : ", nx.diameter(GU, weight = "weight"))
```

L'indice de Wiener, issu de l'étude des réseaux biologiques, correspond à la somme des plus courts chemins entre toutes les paires de sommets. Le réseau orienté n'étant pas fortement connexe, le résultat est une distance infinie (`inf`). Il est possible de prendre en compte la valuation des liens et de chercher la somme des plus courtes distances entre sommets.

```{python}
# indice de wiener (somme des pcc)
print("Indice de Wiener (orienté) : ", nx.wiener_index(GD))     # distance topologique
print("Indice de Wiener (non orienté) : ", nx.wiener_index(GU)) # distance topologique
print("Indice de Wiener (non orienté, valué) : ", nx.wiener_index(GU, 'weight'))  # somme des intensités

```

Mesures dirextement issues de la théorie des graphes, rayon et barycentre (appelé aussi point médian) correspondent respectivement à la distance la plus grande entre deux sommets quelconques d'un graphe (excentricité minimale - cf *infra* les mesures locales) et à l'ensemble de sommets minimisant la fonction $\sum_{u \in V(G)} d_G(u, v)$, $d_G(u, v)$ étant la distance (topologique ou valuée) entre deux sommets $u$ et $v$ de $G$.

```{python}
print("rayon : ", nx.radius(GU))

# barycentre
print("barycentre : ", nx.barycenter(GU))
print("barycentre (valué) : ", nx.barycenter(GU, weight='weight'))
```

La liste du ou des sommets centraux s'obtient avec `center`, la liste des sommets périphériques avec `periphery`. Les premiers correspondent aux sommets ayant une excentricité minimale, les seconds aux sommets ayant une excentricité maximale.

```{python}
print("Sommets centraux : ", nx.center(GU))
print("Sommets périphériques : ", nx.periphery(GU))
```

Il est possible de connaître l'ensemble des isthmes et des points d'articulation présents dans un réseau.

```{python}
# isthmes et points d'articulation (réseau connexe)
# nombre d'isthmes
print("nb isthmes : ", len(list(nx.bridges(GU))))

# liste des isthmes
print("isthmes : ",list(nx.bridges(GU)))

# nombre de points d'articulation
print("nb points d'articulation : ", len(list(nx.articulation_points(GU))))

# liste des points d'articulation
print("points d'articulation : ", list(nx.articulation_points(GU)))
```

Mesure plus récente et liée davantage aux études des physiciennes sur les réseaux, l'assortativité est mesurée par défaut en fonction du degré. Elle varie entre -1 (réseau dissassortatif) et 1 (réseau assortatif). Dans les lignes ci-dessous, les quatre assortativités possibles dans un réseau orienté sont calculées en fonction du degré.

```{python}
# assortativité (degré par défaut)
# orienté
print("assortativité in-in : ", 
      round(nx.degree_assortativity_coefficient(GD, x="in", y='in'),3))

print("assortativité in-out : ", 
      round(nx.degree_assortativity_coefficient(GD, x="in", y='out'),3))

print("assortativité out-in : ", 
      round(nx.degree_assortativity_coefficient(GD, x="out", y='in'),3))

print("assortativité out-out : ", 
      round(nx.degree_assortativity_coefficient(GD, x="out", y='out'),3))

# non orienté
print("assortativité globale (non orienté) : ", 
      round(nx.degree_assortativity_coefficient(GU),3))

# selon un critère autre que le degré (erreur...)
#print(round(nx.numeric_assortativity_coefficient(GD, "MARS"),3))
```


## Mesures locales

Degré : `degree` et `degree_centrality`, `ou_degree` et `in_degree`.
